{"meta":{"title":"Mahan's Blog","subtitle":null,"description":null,"author":"Mahan Rad","url":"http://truelogician.com"},"pages":[{"title":"Categories","date":"2016-08-21T17:17:28.000Z","updated":"2016-08-21T17:07:18.000Z","comments":true,"path":"categories/index.html","permalink":"http://truelogician.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2016-08-22T21:59:06.000Z","updated":"2016-08-21T17:07:18.000Z","comments":true,"path":"about/index.html","permalink":"http://truelogician.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-21T17:17:28.000Z","updated":"2016-08-21T17:07:18.000Z","comments":true,"path":"tags/index.html","permalink":"http://truelogician.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Getting Started with Kafka","slug":"2017/kafka-startup","date":"2017-02-11T21:18:29.000Z","updated":"2017-03-16T18:23:18.000Z","comments":true,"path":"2017/kafka-startup/","link":"","permalink":"http://truelogician.com/2017/kafka-startup/","excerpt":"Kafka is Apache’s open-source platform for distributed stream processing in high throughput environments. In the following tutorial we will try to configure Apache Kafka and Zookeeper as well as demonstrating a basic and a fault tolerant messaging setup.","text":"Kafka is Apache’s open-source platform for distributed stream processing in high throughput environments. In the following tutorial we will try to configure Apache Kafka and Zookeeper as well as demonstrating a basic and a fault tolerant messaging setup. This post tries to cover the following areas on a Linux machine. Kafka Introduction Setting up Kafka Basic Messaging Running a Zookeeper Server Instance Running a Kafka Server Instance Creating and Checking Topics Creating Producer and Consumer Scaled Messaging Creating Zookeeper Ensemble Setting up a Kafka Cluster Creating Replicated Topics Testing Resiliency Kafka IntroductionKafka is a distributed publish/subscribe fault tolerant messaging system with partitioning and replication abilities that is based on distributed commit logs. It can handle high volumes of message streams (more than 1.5 million messages per second). Kafka heavily depends on the Apache Zookeeper maintain its internal states. In a nutshell, Zookeeper is a distributed key-value store used for maintaining configuration information, distributed synchronization, group services and etc. for various distributed applications. However, before diving into the installation and configuration, let’s go through the basic terminology and key facts about Apache Kafka. Kafka Message: is an entity with a arrival timestamp, a unique id and the binary data payload. Topic: is a logical concept; a named feed of messages to be exchanged. Broker: is a software process or node by which Kafka manages topics. They can be scaled out to achieve a higher load distribution, throughput and fault tolerance. Cluster: is a group of brokers (a leader and followers) on one or more hosts Partition: is an immutable sequence of topic messages in a physical log file. A broker could have one or more partitions. One partition cannot be split across machines. Message Offset: is a non-global zero-based immutable sequence-number of a message within a partition that is maintained by consumer. Retention Policy: is Kafka’s configurable period during which the messages are retained by Kafka cluster for a topic. Replication Factor: is the data redundancy factor by which Kafka replicates messages among brokers. In-Sync Replicas (ISR): is the number of in-sync brokers in a topic’s replica-set or quorum. Producer &amp; consumer: entities interested in sending and receiving messages to and from topics. Kafka won’t allow more than 2 consumers to read from the same partition simultaneously. Controller: is an elected broker within a cluster for carrying out administrative tasks (e.g. managing the states of partitions and replicas). Partition Leader: is a broker responsible for recruiting workers for replicating and propagating messages. Follower/Worker: is a broker that only replicates the leader. A broker can simultaneously be the leader for one topic a worker for another topic. Setting up KafkaInstalling Kafka is as easy as downloading and unzipping the archive into a folder. 1234$ cd$ wget http://www-eu.apache.org/dist/kafka/0.10.2.0/kafka_2.12-0.10.2.0.tgz$ tar -xzvf kafka_2.12-0.10.2.0.tgz$ mv kafka_2.12-0.10.2.0 kafka The above script switches to home directory, downloads and unzips kafka and finally removes version from folder name to simplify invocations. Inside kafka/ directory, the bin/ is where all the Kafka and Zookeeper executables exist. Also, the config/ folder as the name suggests, contains the configuration files for both Zookeeper and Kafka. Basic MessagingThe following section demonstrates how to setup a producer/consumer messaging using a single Zookeeper node and a single Kafka broker. Running a Zookeeper Server InstanceIn order to start a Kafka server instance, an instance of the Zookeeper server needs to be running. This is done using the following executable and the instance’s configuration. 1$ sh kafka/bin/zookeeper-server-start.sh kafka/config/zookeeper.properties The instance can be shutdown using ctrl+c or the running the binary below: 1$ sh kafka/bin/zookeeper-server-stop.sh Check the Zookeeper server using: 1$ telnet localhost 2181 followed by a Zookeeper command like ‘stat‘ to produce a similar output as below: 123456789101112131415161718Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.statZookeeper version: 3.4.9-1757313, built on 08/23/2016 06:50 GMTClients: /127.0.0.1:48134[1](queued=0,recved=1107,sent=1109) /127.0.0.1:41180[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/0/115Received: 1259Sent: 1264Connections: 2Outstanding: 0Zxid: 0x22Mode: standaloneNode count: 21Connection closed by foreign host. Running a Kafka Server InstanceNow that a Zookeeper server is up and running, a Kafka server can startup in the same fashion. 1$ sh kafka/bin/kafka-server-start.sh kafka/config/server.properties Again, a ctrl+c or the following binary stops the Kafka server. 1$ sh kafka/bin/kafka-server-stop.sh Creating and Checking TopicsNow let’s create a topic (named ‘TestTopic’) by passing the address to our running Zookeeper instance. Let’s also leave the description to ‘–partitions’ and ‘–replication-factor’ switches for later. 123456$ sh kafka/bin/kafka-topics.sh \\&gt; --create \\&gt; --topic TestTopic \\&gt; --zookeeper localhost:2181 \\&gt; --partitions 1 \\&gt; --replication-factor 1 Use the following commands in order to get the list and description of the created topics. 12$ sh kafka/bin/kafka-topics.sh --list --zookeeper localhost:2181$ sh kafka/bin/kafka-topics.sh --describe --zookeeper localhost:2181 Creating Producer and ConsumerThe only missing parts of the basic messaging is a producer and a consumer that can publish/receive messages on the topic that was created earlier. Let’s create a producer first. 123$ sh kafka/bin/kafka-console-producer.sh \\&gt; --broker-list localhost:9092 \\&gt; --topic TestTopic The above command creates a producer pointing it to where it can find one or more brokers to determine the leader for the given topic. After running the producer console program, it is possible to queue up messages (type and ‘Enter’) to be later fetched by consumer. Now let’s create a consumer for the ‘TestTopic’ topic that receives all the messages published on the topic previously (–from-beginning). 1234$ sh kafka/bin/kafka-console-consumer.sh \\&gt; --bootstrap-server localhost:9092 \\&gt; --from-beginning \\&gt; --topic TestTopic This shall show previously sent messages as well as messages that are sent now by the producer. Scaled MessagingIn basic producer-consumer communication, in case the Zookeeper node or Kafka broker is crashed, the whole messaging fails. However it’s possible to make it fault tolerant by introducing a Zookeeper ensemble (a cluster of Zookeeper nodes) together with a Kafka cluster with multiple brokers (3 Zookeeper nodes and 3 Kafka brokers). Creating Zookeeper EnsembleIf the Zookeeper and Kafka servers are still running from the previous section, stop them and head into ‘config/‘ folder in kafka installation directory. Create 3 files called ‘zoo1.properties‘, ‘zoo2.properties‘ and ‘zoo3.properties‘. Use the following content as a template and copy it to zoo2 and zoo3 and increment the corresponding values of ‘dataDir‘ and ‘clientPort‘. 1234567891011# zoo1.propertiestickTime=2000dataDir=/tmp/zookeeper/1clientPort=2181maxClientCnxns=0initLimit=5syncLimit=2server.1=localhost:2888:3888server.2=localhost:2889:3889server.3=localhost:2890:3890 Essential Properties tickTime: The number of milliseconds to be considered as one tick. dataDir: The server’s data directory. Notice that the /tmp/zookeeper directory might be removed after each restart. clientPort: The port on which this server listens to client connections. maxClientCnxns: Maximum amount of client connections allowed for this server. initLimit: Maximum number of ticks for followers to connect and sync up with leader. syncLimit: Maximum number of ticks for followers to sync up with Zookeeper. server.x: The list of servers that create the Zookeeper ensemble. Also, for each of our servers that will run, we need to create a file called ‘myid’ in their data directory. This file basically consists of a single line and a single number of that machine’s id. 1234567891011$ mkdir -p /tmp/zookeeper/1$ touch /tmp/zookeeper/1/myid$ echo '1' &gt;&gt; /tmp/zookeeper/1/myid$ mkdir -p /tmp/zookeeper/2$ touch /tmp/zookeeper/2/myid$ echo '2' &gt;&gt; /tmp/zookeeper/2/myid$ mkdir -p /tmp/zookeeper/3$ touch /tmp/zookeeper/3/myid$ echo '3' &gt;&gt; /tmp/zookeeper/3/myid Now let’s run the first Zookeeper server in our ensemble. 1$ sh kafka/bin/zookeeper-server-start.sh kafka/config/zoo1.properties After running our server a couple of ‘java.net.ConnectException: Connection refused‘ will be thrown which imply that our server instance cannot connect to the other two (since they are not running yet). So ignore the warning and run the rest of them. 12$ sh kafka/bin/zookeeper-server-start.sh kafka/config/zoo2.properties$ sh kafka/bin/zookeeper-server-start.sh kafka/config/zoo3.properties As of this point, our Zookeeper ensemble with 3 server nodes shall be up and running. Setting up a Kafka ClusterLet’s now create a Kafka cluster with 3 broker inside it which is as easy as running 3 server instances with different configurations. So let’s create 3 properties files kafka-0, kafka-1 and kafka-2 that are only different in values of ‘broker.id‘, ‘port‘ and ‘log.dirs‘. As a result, increment those values for kafka-1.properties and kafka-2.properties. 1234567891011121314151617181920# kafka-0.propertiesbroker.id=0port=9090num.network.threads=3num.io.threads=8socket.send.buffer.bytes=102400socket.receive.buffer.bytes=102400socket.request.max.bytes=104857600log.dirs=/tmp/kafka-logs/0num.partitions=1num.recovery.threads.per.data.dir=1log.retention.hours=168log.segment.bytes=1073741824log.retention.check.interval.ms=300000zookeeper.connect=localhost:2181,localhost:2182,localhost:2183zookeeper.connection.timeout.ms=6000 Essential Properties broker.id: The unique broker id for this server instance. port: A deprecated property denoting the port to which this server listens and accepts connections. log.dirs: The list of directories to maintain data logs. zookeeper.connect: The list of nodes within the Zookeeper ensemble. After creating the properties files with proper content, it’s time to run the Kafka server instances. 123$ sh kafka/bin/kafka-server-start.sh kafka/config/kafka-0.properties$ sh kafka/bin/kafka-server-start.sh kafka/config/kafka-1.properties$ sh kafka/bin/kafka-server-start.sh kafka/config/kafka-2.properties Creating Replicated TopicsAfter having Zookeeper and Kafka brokers up and running, it’s now time to create a couple of topics that 12345678910111213$ sh kafka/bin/kafka-topics.sh \\&gt; --create \\&gt; --topic chat \\&gt; --zookeeper localhost:2181,localhost:2182,localhost:2183 \\&gt; --replication-factor 3 \\&gt; --partitions 3$ sh kafka/bin/kafka-topics.sh&gt; --create \\&gt; --topic event \\&gt; --zookeeper localhost:2181,localhost:2182,localhost:2183 \\&gt; --replication-factor 2 \\&gt; --partitions 2 1$ sh kafka/bin/kafka-topics.sh --describe --zookeeper localhost:2181 1234Topic:chat PartitionCount:1 ReplicationFactor:3 Configs: Topic: chat Partition: 0 Leader: 1 Replicas: 1,2,0 Isr: 1,2,0Topic:event PartitionCount:1 ReplicationFactor:2 Configs: Topic: event Partition: 0 Leader: 0 Replicas: 0,1 Isr: 0,1 The output is the description of topics and their relation with existing brokers. The first two lines of output state that the topic ‘chat’ has one partition that is replicated among brokers 1,2 and 3 while all three of them are in sync at the moment (Isr: 1,2,0). The rest of the output demonstrate similar information for the ‘event’ topic. In order to get a better understanding, compare it with the diagram shown at the beginning of the post. Testing ResiliencyIt’s now time to create one consumer and one producer for our ‘chat’ topic (the same will stand for the ‘event’ topic as well) and test how resilient our setup is. 123$ sh kafka/bin/kafka-console-producer.sh \\&gt; --broker-list localhost:9092 \\&gt; --topic chat 123$ sh kafka/bin/kafka-console-consumer.sh \\&gt; --bootstrap-server localhost:9092 \\&gt; --from-beginning --topic chat Try to send a few messages to ensure the setup works in the first place. According to the ‘chat’ topic description, broker1 is the topic leader. However, if that broker is killed, Kafka will elect another broker as the topic’s leader. Test this by killing broker 1 and issuing the topic description command which shall produce a similar output as below: 1234Topic:chat PartitionCount:1 ReplicationFactor:3 Configs: Topic: chat Partition: 0 Leader: 2 Replicas: 1,2,0 Isr: 2,0Topic:event PartitionCount:1 ReplicationFactor:2 Configs: Topic: event Partition: 0 Leader: 0 Replicas: 0,1 Isr: 0 As can be seen, the producer and consumer are not affected and messages can still be passed; however, the topics are. The ‘chat’ topic has now the broker2 as its new leader and has only 2 ISRs while topic ‘event’ now owns only 1 ISR. To further test the setup resiliency, try to kill a Zookeeper node and see that messaging will not fail until all nodes are down.","categories":[{"name":"Kafka","slug":"Kafka","permalink":"http://truelogician.com/categories/Kafka/"},{"name":"Startup","slug":"Kafka/Startup","permalink":"http://truelogician.com/categories/Kafka/Startup/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Kafka","slug":"Kafka","permalink":"http://truelogician.com/tags/Kafka/"},{"name":"Messaging","slug":"Messaging","permalink":"http://truelogician.com/tags/Messaging/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://truelogician.com/tags/Zookeeper/"},{"name":"Messaging System","slug":"Messaging-System","permalink":"http://truelogician.com/tags/Messaging-System/"},{"name":"Event Sourcing","slug":"Event-Sourcing","permalink":"http://truelogician.com/tags/Event-Sourcing/"}],"keywords":[{"name":"Kafka","slug":"Kafka","permalink":"http://truelogician.com/categories/Kafka/"},{"name":"Startup","slug":"Kafka/Startup","permalink":"http://truelogician.com/categories/Kafka/Startup/"}]},{"title":"Enhance Your Hexo Blog","slug":"2016/hexo-install-plugins","date":"2016-08-23T20:22:01.000Z","updated":"2017-03-15T14:38:52.000Z","comments":true,"path":"2016/hexo-install-plugins/","link":"","permalink":"http://truelogician.com/2016/hexo-install-plugins/","excerpt":"This tutorial covers how you can enhance your Hexo blog. If you have not yet create it, you might want to check out the quick start with Hexo, otherwise let’s go through a few essential plug-ins that might leverage your blog’s usability very briefly. You can find the detailed list of plug-ins here.","text":"This tutorial covers how you can enhance your Hexo blog. If you have not yet create it, you might want to check out the quick start with Hexo, otherwise let’s go through a few essential plug-ins that might leverage your blog’s usability very briefly. You can find the detailed list of plug-ins here. Comments &amp; DiscussionsOne of the most important features of a blog is perhaps the possibility to interact with your readers and that will keep them coming back. disqus is a popular commenting service that works through the Javascript snippet within your page. What you need to do to modify your blog with a full fledged commenting service is to sign up for a disqus account, register your site and pick a unique short-name for your blog and paste it in your _config.yaml file, right below your theme name as shown here. 1disqus_shortname: &lt;your-disqus-shortname&gt; Blog SearchUsing this plug-in, you can empower your blog reader with the ability of searching through your posts. 1$ npm install hexo-generator-json-content --save Right after installation, the plug-in should work properly out of the box (after running hexo generate or hexo server). however, in order to through details of configuration you might want to check its Github page or your theme’s “_config.yaml” file. RSS FeedYou can enable your blog with an RSS feed out of your posts in hexo by installing this plug-in. 1$ npm install hexo-generator-feed --save The plug-in can be configured in the _config.yaml with the following configuration section. 1234feed: type: atom path: atom.xml limit: 20 Markdown SupportThis plug-in provides more support on the markdown such as GFM (Github Flavored Markdown) tables and line breaks. 1$ npm install hexo-renderer-marked --save You can customize the plug-in by pasting the following in your _config.yaml and changing the values. 12345678marked: gfm: true pedantic: false sanitize: false tables: true breaks: true smartLists: true smartypants: true Category GeneratorThis plug-in allows you to assign one or more tags to your post. It will group your posts and enables your readers to later on find out about all of posts that are tagged with the same category. 1$ npm install hexo-generator-category --save and the related options are as follows: 12category_generator: per_page: 10 CNAME GeneratorThis plug-in will automatically generate a Github pages CNAME file. 1$ npm install hexo-generator-cname --save This plug-in does not require any specific configuration. Only make sure to change your blog’s url to the real one in the _config.yaml 123# URL## If your site is put in a subdirectory, set URL as 'http://yoursite.com/child' and root as '/child/'url: &lt;real-blog-url&gt; Git DeployerThis plug-in will help you deploy your blog using git. 1$ npm install hexo-deployer-git --save You can configure the deploy plug-in like this: 1234deploy: type: git repo: https://github.com/&lt;username&gt;/&lt;repository&gt; branch: master Deploy to GithubWhen you are ready to deploy your blog to the Github, run the following commands to generate your blog and deploy it to the specified branch in your Github repository as you setup before. 12$ hexo generate$ hexo deploy Now that you have your generated blog on Github, you can configure and connect your custom domain to load your blog from Github.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://truelogician.com/categories/Hexo/"},{"name":"Plugins","slug":"Hexo/Plugins","permalink":"http://truelogician.com/categories/Hexo/Plugins/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Hexo","slug":"Hexo","permalink":"http://truelogician.com/tags/Hexo/"},{"name":"Blogging","slug":"Blogging","permalink":"http://truelogician.com/tags/Blogging/"},{"name":"StaticWebsite","slug":"StaticWebsite","permalink":"http://truelogician.com/tags/StaticWebsite/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://truelogician.com/categories/Hexo/"},{"name":"Plugins","slug":"Hexo/Plugins","permalink":"http://truelogician.com/categories/Hexo/Plugins/"}]},{"title":"Creating a Blog by Hexo","slug":"2016/hexo-quick-start","date":"2016-07-14T19:55:50.000Z","updated":"2016-09-18T15:36:36.000Z","comments":true,"path":"2016/hexo-quick-start/","link":"","permalink":"http://truelogician.com/2016/hexo-quick-start/","excerpt":"Have you ever wished you could create your own blog in no time? Did you get frustrated as you thought you might not have enough time to design and set it up? Do you also wish to have more control over your blog comparing to other blogs such as those in WordPress?","text":"Have you ever wished you could create your own blog in no time? Did you get frustrated as you thought you might not have enough time to design and set it up? Do you also wish to have more control over your blog comparing to other blogs such as those in WordPress? Well, that was exactly the case for me and if it’s the same for you, then give “static site generators” a go. What is a “Static Site Generator”?In short, a static site generator is basically a HTML file generator. It crates and formats HTML files by using its template engine as well as your text which is usually in a format such as markdown. Static site generators are very much easy to setup and use while providing users with more control over it. You can choose and heavily customize themes, choose among plenty of plug-ins and finally host your website on Github pages for free. What is Hexo?According to Hexo’s documentation, Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. -Alright, now let’s dive in. Installing HexoBefore installing hexo, use your OS package manager to update and cleanup system packages. 1$ brew update --all &amp;&amp; brew upgrade --all &amp;&amp; brew cleanup &amp;&amp; brew doctor &amp;&amp; brew prune Install Node.jsHexo is a node.js package. As a result, we first need to install the node.js in case it’s not. 1$ brew install node On Linux machines, the procedure is similar with the distro’s package manager. On Windows machines, please refer to this page for download. npm is the default package manager of the node.js. In case you have had the node installed for some time, make an update and clean the previously installed packages. We will later on use npm to install all the required packages in our blog. 1$ npm update &amp;&amp; npm upgrade &amp;&amp; npm cache clean Now, we can actually install the Hexo package. 1$ npm install hexo-cli -g Creating Your First BlogNow, in order to create a blog, goto a directory in which you want to create a blog. 1$ hexo init blog After the blog directory is created, change directory (cd) to the created folder and download all the node modules we need to run and manage our blog. 12$ cd blog$ npm install Running Your Blog serverNow let’s clean (not needed for the first time but it’s a good practice), generate and run the blog on a node server on the default port 4000. 1$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server You can now view your blog locally on your browser. Creating Post, Page or DraftIn order to create more posts, you simply need to create .md files within your _posts folder. Additionally, Hexo also provides the following sugar coated commands to create a post, page or draft. 1234$ hexo new \"My Post\"$ hexo new post \"My Post\"$ hexo new page \"About Me\"$ hexo new draft \"My Post\" Now that you have a post, open it in your favorite editor and write your content in markdown language. Having a cheat sheet at your disposal is also a good idea while you are writing in Markdown. At this point you have a working blog (with the default theme). You might want to apply and customize a different theme. Hexo provides a handful of themes on their website that you can choose from. In addition to themes, plenty of plug-ins are also available for hexo that can totally enhance your blog and your reader’s experience form it. So, if you still eager about improving your blog and connect a couple of useful plug-ins, read further on the next section.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://truelogician.com/categories/Hexo/"},{"name":"Startup","slug":"Hexo/Startup","permalink":"http://truelogician.com/categories/Hexo/Startup/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Hexo","slug":"Hexo","permalink":"http://truelogician.com/tags/Hexo/"},{"name":"Blogging","slug":"Blogging","permalink":"http://truelogician.com/tags/Blogging/"},{"name":"StaticWebsite","slug":"StaticWebsite","permalink":"http://truelogician.com/tags/StaticWebsite/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://truelogician.com/categories/Hexo/"},{"name":"Startup","slug":"Hexo/Startup","permalink":"http://truelogician.com/categories/Hexo/Startup/"}]},{"title":"FlatMap","slug":"2015/flatmap","date":"2015-04-26T19:46:12.000Z","updated":"2017-03-16T20:45:16.000Z","comments":true,"path":"2015/flatmap/","link":"","permalink":"http://truelogician.com/2015/flatmap/","excerpt":"One of the most crucial and important concepts in mastering reactive extensions is understanding flatMap() and the uses of it which is mainly due to the fact that even a fairly simple application tend to work with multiple observables.","text":"One of the most crucial and important concepts in mastering reactive extensions is understanding flatMap() and the uses of it which is mainly due to the fact that even a fairly simple application tend to work with multiple observables.However, before understanding flatMap, we need to learn its simpler version, the map() operator and the details around using it. map(), Transformation On-the-flySometimes you want to perform a transformation on each and every event from the upstream as soon as they arrive and pack them into a new observable for the downstream subscribers. In other words, map() constructs Observable and replaces all upstream values of type T with R using your desired mapping function. The snippet below takes integer values and maps items to corresponding strings embellished with double quotes. 12345Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3);Observable&lt;String&gt; map1 = observable.map(n -&gt; \"\\\"\" + n + \"\\\"\");map1.subscribe(log::info); 123[main] - &quot;1&quot;[main] - &quot;2&quot;[main] - &quot;3&quot; We could also use multiple map() operators together. 1234Observable&lt;Instant&gt; map = observable .map(order -&gt; order.getUser()) .map(user -&gt; user.birthDate()) .map(Date::toInstant); So far, each event within the upstream was a simple object, but what if the computation used for mapping is asynchronous or already return observables? 12345678910Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3);Observable&lt;Observable&lt;Integer&gt;&gt; map = observable.map(integer -&gt; Observable.timer(1, SECONDS) .map(s -&gt; integer) );map.subscribe(log::info); 123[main] - rx.Observable@36f6e879[main] - rx.Observable@5a61f5df[main] - rx.Observable@3551a94 Using flatMap()Since working with nested observables are cumbersome as you need to subscribe to each inner Observable and synchronize the results back into a single stream, flatMap() was created. flatMap() does the following in order: constructs Observable","categories":[{"name":"Reactive","slug":"Reactive","permalink":"http://truelogician.com/categories/Reactive/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Reactive Programming","slug":"Reactive-Programming","permalink":"http://truelogician.com/tags/Reactive-Programming/"},{"name":"Reactive Extensions","slug":"Reactive-Extensions","permalink":"http://truelogician.com/tags/Reactive-Extensions/"},{"name":"RxJava","slug":"RxJava","permalink":"http://truelogician.com/tags/RxJava/"}],"keywords":[{"name":"Reactive","slug":"Reactive","permalink":"http://truelogician.com/categories/Reactive/"}]},{"title":"Observables & Subscriptions","slug":"2015/observables","date":"2015-03-02T21:17:36.000Z","updated":"2017-02-08T06:15:48.000Z","comments":true,"path":"2015/observables/","link":"","permalink":"http://truelogician.com/2015/observables/","excerpt":"Now that we are familiar with reactive programming concepts and that Observable resides at the core of it, let’s find out about the ways we can create and use simple observables.","text":"Now that we are familiar with reactive programming concepts and that Observable resides at the core of it, let’s find out about the ways we can create and use simple observables. ReviewAs mentioned earlier, observables are lazy by default and accordingly in order to begin seeing observables outputs there should be at least one subscriber such as the one mentioned below. 123456Observable&lt;T&gt; obsevable = //...observable.subscribe( (i) -&gt; System.out.println(i), (e) -&gt; System.out.println(e), ( ) -&gt; System.out.println(\"completed\")); Notice that the event callback is invoked each time upstream pushes an event to downstream and that the callback will not be invoked from more than one thread at a time. In the output given for each snippet, the thread name on which the code being executed is mentioned. 1- ObservablesFactory MethodsThere are a few factory methods to create fixed Observables. Except interval(interval, unit) method, the rest of factory methods execute on the client thread meaning that they block the client thread until all events are received. Observable.just(value)This method creates an Observable instance that only emits the given values and then completes afterward. 12Observable&lt;String&gt; observable = Observable.just(\"hello world!\"); 12[main] - hello world![main] - completed 12Observable&lt;String&gt; observable = Observable.just(\"one\", \"two\", \"three\"); 1234[main] - one[main] - two[main] - three[main] - completed 12Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3); 1234[main] - 1[main] - 2[main] - 3[main] - completed Observable.from(values)This method creates an Observable from the given collection or iterable and emits its values. 12Observable&lt;Integer&gt; fibonacci = Observable.from(new Integer[] &#123; 1, 2, 3, 5, 8 &#125;); 123456[main] - 1[main] - 2[main] - 3[main] - 5[main] - 8[main] - completed 123456MongoCollection&lt;Document&gt; employees = db.getCollection(\"employees\");Observable .from(employees.find()) .doAfterTerminate(() -&gt; &#123; // what needs to be done after termination &#125;); 12[main] - Document&#123;&#123;_id=589a3ebfb371aa47cfa03e1c, name=John Doe, salary=1234.0&#125;&#125;[main] - Document&#123;&#123;_id=589a3edeb371aa47cfa03e1d, name=James Brown, salary=4321.0&#125;&#125; Observable.range(from, n)Produces an Observable and emits n integer numbers starting from ‘from’. For example, range(5, 3) will emit 5, 6, and 7 and then complete normally. 12Observable&lt;Integer&gt; observable = Observable.range(10, 5); 1234567[main] - 10[main] - 11[main] - 12[main] - 13[main] - 14[main] - 15[main] - completed Observable.interval(interval, unit)This factory method creates a cold observable that emits long numbers starting from zero and a fixed delay between each number including the first one. Notice that since numbers are emitted on the computation thread, in order to see some results, you need to block the main thread. 123Observable&lt;Long&gt; observable = Observable.interval(2, TimeUnit.SECONDS); // 1, 2, 3, 4, 5, ... 1234[RxComputationScheduler-2] - 0[RxComputationScheduler-2] - 1[RxComputationScheduler-2] - 2... Observable.create(…)Use this method, if you need more control over unsubscribes as well as production and consumption of events. The following snippet rapidly produces integers starting from zero. 123456789101112Observable&lt;Integer&gt; observable = Observable.create( subscriber -&gt; &#123; Runnable r = () -&gt; &#123; int i = 0; while (!subscriber.isUnsubscribed()) subscriber.onNext(i++); &#125;; new Thread(r).start(); &#125;); pause(1); subscription.unsubscribe(); pause(0); 1234567[Thread-0] - 0[Thread-0] - 1[Thread-0] - 2[Thread-0] - 3[Thread-0] - 4[Thread-0] - 5[Thread-0] - 6 When creating observables by create() method, in order to avoid sending unnecessary events when there are no subscribers, check the isUnsubscribed() as often as possible.Also notice that these custom implementations of Observable should ensure that events coming from multiple threads are called in a serialized fashion. Observable.fromCallable(…)This factory method creates an Observable from the value that is returned by another method (callable). The following snippet create a product Observable by fetching the product by its ID. This method is semantically the same as create() but much more concise. 123Observable&lt;Product&gt; load(int productId) &#123; return Observable.fromCallable(() -&gt; findById(productId));&#125; Composing Observableswhile composing observables, we can: A: Wait for corresponding events, process them and emit the results. In the following example the corresponding events of the first two Observable are added and emitted as the third one. 123456Observable&lt;Integer&gt; one = Observable.range(10, 100);Observable&lt;Long&gt; two = Observable.interval(2, SECONDS);Observable .zip(one, two, (l1, l2) -&gt; l1 + l2) .subscribe(log::info); 123456[RxComputationScheduler-2] - 10 # 10 + 0[RxComputationScheduler-2] - 12 # 11 + 1[RxComputationScheduler-2] - 14 # 12 + 2[RxComputationScheduler-2] - 16 # 13 + 3[RxComputationScheduler-2] - 18 # 14 + 4... B: Compose a stream from the first two Observable which emits events they are arrive. 12345Observable&lt;Integer&gt; one = Observable.range(10, 2);Observable&lt;Long&gt; two = Observable.interval(1, SECONDS);Observable .merge(one, two) .subscribe(log::info); 123456[main] - 10[main] - 11[RxComputationScheduler-1] - 0[RxComputationScheduler-1] - 1[RxComputationScheduler-1] - 2... 2- SubscriptionsAs stated earlier, having a reference to a subscriber instance together with using add() method we can be notified of unsubscribe and perform suitable action. We only need to attach the unsubscribe action to a subscription and add it to the list of subscriber’s subscriptions. 123Subscription onUnsubscribe = Subscriptions.create(() -&gt; in.close());subscriber.add(onUnsubscribe); It is important to unsubscribe from an Observable as soon as you no longer want to receive more events and Subscription provides just a way to do that using unsubscribe() method. Multiple Subscribers123456789Observable&lt;Integer&gt; o1 = Observable.create(subscriber -&gt; &#123; log.info(\"generating values\"); subscriber.onNext(1); subscriber.onNext(2); subscriber.onNext(3); &#125;);o1.subscribe(log::info);o1.subscribe(log::info); 12345678[main] - generating values[main] - 1[main] - 2[main] - 3[main] - generating values[main] - 1[main] - 2[main] - 3 Unsubscribing from Outside.12345678910Observable&lt;Long&gt; one = Observable.interval(1, TimeUnit.SECONDS);Subscription subscription = one.subscribe(log::info);try &#123; Thread.currentThread().sleep(2000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;subscription.unsubscribe(); 1234[RxComputationScheduler-1] - 0[RxComputationScheduler-1] - 1Process finished with exit code 0 Unsubscribing from Inside.12345678910111213141516171819Observable&lt;Integer&gt; one = Observable.from(new Integer[] &#123; -2, -1, 0, 1, 2&#125;);Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;Integer&gt;() &#123; @Override public void onNext(Integer i) &#123; if (i == 0) unsubscribe(); log.info(i); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onCompleted() &#123; log.info(\"completed\"); &#125;&#125;;one.subscribe(subscriber); 12345[main] - -2[main] - -1[main] - 0Process finished with exit code 0 Sharing an ObservableConnectableObservableSometimes multiple subscribers are interested in your observable and you might none of them to miss any early emitted events. Without ConnectableObservable, hot observables will emit items and late subscribers might lose some of them. A ConnectableObservable is an Observable that emits events to subscribers only when its connect() method is invoked. When this happens, a dedicated subscriber is assigned to the upstream which emits exactly the same sequence of events to all downstream subscribers. It ensures that the upstream Observable has at most one Subscriber as it opens only one subscription to the original Observable. The following code tries to make a comparison between normal observable and a connectable observable with two subscribers. Notice how in case of ConnectableObservable, both subscribers experience the same events at the same time. 123456789101112131415161718192021222324252627Observable&lt;Integer&gt; observable = Observable.create( subscriber -&gt; &#123; log.info(\"connecting...\"); Runnable r = () -&gt; &#123; subscriber.onNext(1); subscriber.onNext(2); subscriber.onNext(3); &#125;; new Thread(r).start(); Subscription s = Subscriptions.create( () -&gt; log.info(\"disconnecting...\") ); subscriber.add(s); &#125;);log.info(\"before subscription\");Subscription sub1 = observable.subscribe(i -&gt; log.info(\"sub1: \" + i));log.info(\"sub1 subscribed\");Subscription sub2 = observable.subscribe(i -&gt; log.info(\"sub2: \" + i));log.info(\"sub2 subscribed\");sub1.unsubscribe();log.info(\"sub1 unsubscribed\");sub2.unsubscribe();log.info(\"sub2 unsubscribed\"); 12345678910111213141516171819[main] - before subscription[main] - connecting...[Thread-0] - sub1: 1[Thread-0] - sub1: 2[Thread-0] - sub1: 3[main] - sub1 subscribed[main] - connecting...[main] - sub2 subscribed[Thread-1] - sub2: 1[Thread-1] - sub2: 2[Thread-1] - sub2: 3[main] - disconnecting...[main] - sub1 unsubscribed[main] - disconnecting...[main] - sub2 unsubscribed The publish() operator converts a normal observable to a ConnectableObservable. Finally, the connect() method causes the ConnectableObservable to start emitting events. 123456789101112131415161718// the same observable as previous example// ...ConnectableObservable&lt;Integer&gt; shared = observable.publish();log.info(\"before subscription\");Subscription sub1 = shared.subscribe(s -&gt; log.info(\"sub1: \" + s));log.info(\"sub1 subscribed\");Subscription sub2 = shared.subscribe(s -&gt; log.info(\"sub2: \" + s));log.info(\"sub2 subscribed\");shared.connect();sub1.unsubscribe();log.info(\"sub1 unsubscribed\");sub2.unsubscribe();log.info(\"sub2 unsubscribed\"); 123456789101112131415[main] - before subscription[main] - sub1 subscribed[main] - sub2 subscribed[main] - connecting...[Thread-0] - sub1: 1[Thread-0] - sub2: 1[Thread-0] - sub1: 2[Thread-0] - sub2: 2[Thread-0] - sub1: 3[Thread-0] - sub2: 3[main] - sub1 unsubscribed[main] - sub2 unsubscribed Notice and compare the threads on which subscribers receive the events. publish().refCount() or share()The publish().refCount() duet is so commonly used for sharing observables that the alias of share() is created for them. share() basically subscribes to the upstream Observable and shares it if there is at least one active subscriber. It also unsubscribes from upstream as soon as the last active subscriber unsubscribes. 123456789101112131415161718192021222324252627282930313233Observable&lt;Integer&gt; observable = Observable.create( subscriber -&gt; &#123; log.info(\"connecting...\"); Runnable r = () -&gt; &#123; try &#123; subscriber.onNext(1); Thread.currentThread().sleep(1000); subscriber.onNext(2); Thread.currentThread().sleep(1000); subscriber.onNext(3); &#125; catch (InterruptedException e) &#123; log.error(e); &#125; &#125;; new Thread(r).start(); Subscription s = Subscriptions.create( () -&gt; log.info(\"disconnecting...\") ); subscriber.add(s); &#125;); Observable&lt;Integer&gt; shared = observable.share(); log.info(\"before subscription\"); Subscription sub1 = shared.subscribe(s -&gt; log.info(\"sub1: \" + s)); log.info(\"sub1 subscribed\"); pause(500); Subscription sub2 = shared.subscribe(s -&gt; log.info(\"sub2: \" + s)); log.info(\"sub2 subscribed\"); 123456789[main] - before subscription[main] - connecting...[main] - sub1 subscribed[Thread-0] - sub1: 1[main] - sub2 subscribed[Thread-0] - sub1: 2[Thread-0] - sub2: 2[Thread-0] - sub1: 3[Thread-0] - sub2: 3","categories":[{"name":"Reactive","slug":"Reactive","permalink":"http://truelogician.com/categories/Reactive/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Reactive Programming","slug":"Reactive-Programming","permalink":"http://truelogician.com/tags/Reactive-Programming/"},{"name":"Reactive Extensions","slug":"Reactive-Extensions","permalink":"http://truelogician.com/tags/Reactive-Extensions/"},{"name":"RxJava","slug":"RxJava","permalink":"http://truelogician.com/tags/RxJava/"},{"name":"Observable","slug":"Observable","permalink":"http://truelogician.com/tags/Observable/"},{"name":"Subscription","slug":"Subscription","permalink":"http://truelogician.com/tags/Subscription/"},{"name":"Subscriber","slug":"Subscriber","permalink":"http://truelogician.com/tags/Subscriber/"}],"keywords":[{"name":"Reactive","slug":"Reactive","permalink":"http://truelogician.com/categories/Reactive/"}]},{"title":"Reactive Extensions Basics","slug":"2015/rxbasics","date":"2015-02-09T17:15:36.000Z","updated":"2016-12-24T08:58:19.000Z","comments":true,"path":"2015/rxbasics/","link":"","permalink":"http://truelogician.com/2015/rxbasics/","excerpt":"The Reactive Extensions (Rx in short) are the libraries provided for a set of programming languages with the aim of simplifying development of asynchronous, event-based applications using streams (observable) and LINQ-style query operators.","text":"The Reactive Extensions (Rx in short) are the libraries provided for a set of programming languages with the aim of simplifying development of asynchronous, event-based applications using streams (observable) and LINQ-style query operators. Reactive manifesto is a document describing reactive systems and the standards of quality software applications or components and is based on four primary concepts of responsiveness, resilience, elasticity and message driven. The reactive extensions libraries enable developers to easily create reactive programs that cater for those principles in essence. The following and the rest of the series tries to have a brief overview of the main features of reactive extensions in RxJava. ObservablesObservables are the building blocks of reactive systems. An Observable is an event stream; a sequence of events or data transmitted by a producer (Observable) to a consumer (Observer). It can be used in replace of a List, Iterable, or Stream. Think of an Observable as a pipeline of data flowing from one end to another. Additionally, the concepts of upstream, downstream, hot and cold observables are repeatedly used and worth mentioning beforehand. An upstream is the source stream from which we are receiving data while a downstream is the destination stream to which we are sending data. Cold observables are those that never begin to emit events unless at least one interested party is subscribed to them. This means that each subscriber of a cold Observable receives a full copy of the same stream top to bottom. Hot Observables are those that push the events downstream regardless of any subscription. As a result of this, events may get lost and subscribers might receive the events from various parts of the observable stream. Core InterfacesAt the core of RxJava, there is the Observable type which represents a stream of data or events to be received by an Observer over time. 123interface Observable&lt;T&gt; &#123; Subscription subscribe(Observer o);&#125; An Observer can connect to Observable through Subscription and can receive three kinds of events. Data or events: are pushed via the onNext() method. Exceptions: are pushed via the onError() method. Stream Completion is notified via the onCompleted() method. After the first exception occurrence or the stream completion, the underlying Observable stream is finished immediately and cannot be reused any more and no further events can be sent over that stream. Accordingly, these events (exception and completion) are called terminal events.In case of infinite streams, the terminal events might never occur if the stream is infinite and does not fail. 12345interface Observer&lt;T&gt; &#123; void onNext(T t); void onError(Throwable t); void onCompleted();&#125; The Subscriber wraps the Observer to provide the ability of unsubscribe from the Observable stream. 12345678interface Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription &#123; void onNext(T t); void onError(Throwable t); void onCompleted(); ... void unsubscribe(); void setProducer(Producer p);&#125; Comparison of Non-Reactive &amp; Reactive SystemsPull vs. PushIn traditional approaches, items are pulled gradually from the source to be processed. However, the main intent of Observable is to push the data or events (Observable can be used with pulling too). In fact, this shift from pull-base to push-base processing could be considered the whole point of RxJava. Sync vs. AsyncNon reactive systems tend to consume source data synchronously while blocking the requesting thread. Reactive components, however, use the fire and forget approach as a result being push-based. Note that an Observable can be used asynchronously or synchronously. They are synchronous by default as they block the subscribing thread and emit events via onNext(). Using callbacks which is a common pattern to achieve asynchronicity has its own few drawbacks including the hassle of coordinating them, their tendency to be nested to create a Christmas tree code as well as sever refactoring a callback-based API into RxJava. Despite being asynchronous, an Observable stream is always serialized and thread-safe meaning that onNext(), onCompleted() or onError() cannot concurrently execute (e.g. onNext() will not be invoked from different threads). Eager vs. LazyTraditional systems are mainly eager. This means that evaluations will occur regardless of an subscriber’s presence.In contrast, laziness implies postponing the evaluations and computations until they are certainly asked by a subscriber/client.This is a very useful feature while performing calculation and stream composition.","categories":[{"name":"Reactive","slug":"Reactive","permalink":"http://truelogician.com/categories/Reactive/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Reactive Programming","slug":"Reactive-Programming","permalink":"http://truelogician.com/tags/Reactive-Programming/"},{"name":"Reactive Extensions","slug":"Reactive-Extensions","permalink":"http://truelogician.com/tags/Reactive-Extensions/"},{"name":"RxJava","slug":"RxJava","permalink":"http://truelogician.com/tags/RxJava/"}],"keywords":[{"name":"Reactive","slug":"Reactive","permalink":"http://truelogician.com/categories/Reactive/"}]},{"title":"Introduction to Akka","slug":"2014/introduction-to-akka","date":"2014-06-12T19:21:34.000Z","updated":"2016-08-31T11:07:35.000Z","comments":true,"path":"2014/introduction-to-akka/","link":"","permalink":"http://truelogician.com/2014/introduction-to-akka/","excerpt":"The following intends to provide a brief introduction to Akka which is framework based on the actor model and designed to increase the abstraction, scalability and fault-tolerance of systems. It provides a platform enabling developers to easily create concurrent and loosely coupled applications with the ability of self-healing in the face of failures.","text":"The following intends to provide a brief introduction to Akka which is framework based on the actor model and designed to increase the abstraction, scalability and fault-tolerance of systems. It provides a platform enabling developers to easily create concurrent and loosely coupled applications with the ability of self-healing in the face of failures. Typical Problems of Complex SystemsBelow is mentioned a few of the more important problems and issues that need to be addressed when dealing with more complex systems: Threads tend to need a lot of coordination logic, locks and synchronizations. The amount of threads to be used within an application is limited. It is usually hard to scale up, scale out, deploy and run the complex applications. Creating fault tolerant applications that can recover form errors is tedious. It is cumbersome to modify applications and systems with load balancing. How Akka Addresses the Issues?Alright, now that we know some of the top issues, let’s also mention a few key notes about what Akka has to offer in general and what it brings to the table to address them. Akka pushes the burden of low-level thread management and thread-safe code to the actor model. The use of actor model also makes Akka to be aligned with reactive manifesto which improves applications in the following terms: Message-Driven:Asynchronous message passing decreases coupling and provides location transparency for system components. Resilience:Akka enforces single responsibility through component isolation (actors). Elasticity:As systems scale, they will still be able to handle various workloads. In addition, actors can be increased in amount where they are exactly needed and they also can divide the workload among themselves. Responsiveness:Loose coupling, Resilience and Elasticity will make the system responsive. The increases in abstraction and loose coupling will also result into: Reduction in use of shared states among components. Increase in CPU utilization. Increase in capability to scale up and out. Increasing system fault-tolerance. So, What is an Actor?Definition: an actor is a fundamental primitive unit of computation or work which basically means that they are designed to perform small, simple and well-defined tasks. In order to better imagine and understand what an actor is, let’s start getting to know about their behavior and attributes. Each actor has a unique address and hence location transparent. Each actor has a mailbox (queue of messages), state and behavior. Actors are very lightweight (2.7 Million per 1GB of RAM). They are formed in hierarchies/trees (parent child relationship). They can live and communicate on different machines. They can create child actors. They can heal their children. They can supervise their children. They can change their behavior. They only communicate with one or more actors via message passing. They can only handle one message at a time. They can decide what to do with the message. Their states are only known by querying them (sending messages). Note: The fact that actors come in hierarchies and that they can heal their children can really help developers push the risky and error-prone logic to child actors (or leaves); Therefore, as soon as a child dies, its parent is notified and supervises it accordingly. What is an Actor-System (node)?A node or an actor-system groups several actors and thus, an instance of it can contain one or more actors. According to this definition, we can now have local or remote actors. Let’s say actor “a” lives on actor-system “X”; in this case: Local Actor: An actor “b” is local to actor “a”, if “b” lives on the same actor-system as “a” (meaning actor-system “X”). Remote Actor: An actor “b” is remote to actor “a”, if “b” lives on a different actor-system (let’s say actor-system “Y”). Also note that actor-system “Y” might be located on the same or a separate machine. Using addresses, an actor in one actor-system can send messages to local actor or remote actors. The address of an actor follows the format below and consists of these parts. 1[protocol]://[actor-system]@[hostname]:[port] Details of Actors Actions Creating Actor: With a name and certain properties (called props), actors can create other child actors. Sending Messages: An actor can send message to a local or remote actor. Passing messages among actors are async and non-blocking (Fire &amp; Forget). Actors are totally inactive/passive until they receive a message. Actors can handle throughput of 50 million messages per second per machine. The order of messages are maintained the same for sender and receiver. Changing Behavior: An actor can change its behavior at runtime. This change in behavior is triggered after receiving a message. Supervising Children: Actors can supervise their child actors. Child actors send failure signal and the parent instruct them what to do. The child does not need to know how to handle the error. Actors can supervise their children even over separate physical nodes. There are several error supervising strategies they can pick from. these strategies basically indicate what to do if a child fails in general or of a certain event. The strategy options are: resume / restart / escalate Note: In Akka, the message transport and the message delivery are completely separated processes. Akka uses concurrent-linked-queue as the mailbox, however one can define what message queue to use either per actor or per actor-system (node). Its also possible to use broker and let broker handle messaging. Properties of an Akka MessageAn Akka message is a simple immutable data container defined by user and is created and passed asynchronously among actors. Akka messages also aligned with the definition of a message in reactive manifesto. A message is an item of data that is sent to a specific destination. In a message driven system, addressable recipients await the arrival of messages and react to them, otherwise lying dormant (Reactive Manifesto).","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Akka","slug":"Software-Architecture/Akka","permalink":"http://truelogician.com/categories/Software-Architecture/Akka/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Akka","slug":"Akka","permalink":"http://truelogician.com/tags/Akka/"},{"name":"Distributed-Systems","slug":"Distributed-Systems","permalink":"http://truelogician.com/tags/Distributed-Systems/"},{"name":"Actor Model","slug":"Actor-Model","permalink":"http://truelogician.com/tags/Actor-Model/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Akka","slug":"Software-Architecture/Akka","permalink":"http://truelogician.com/categories/Software-Architecture/Akka/"}]},{"title":"Git on USB Stick","slug":"2014/gitstick","date":"2014-04-23T12:05:38.000Z","updated":"2016-10-28T17:31:57.000Z","comments":true,"path":"2014/gitstick/","link":"","permalink":"http://truelogician.com/2014/gitstick/","excerpt":"Sometimes within your development team, you might want to create a new or port an existing local Git repository to a USB drive/stick and share it. In such cases, what you need is to create a bare repository so that all developers can collaborate and push their changes to it.","text":"Sometimes within your development team, you might want to create a new or port an existing local Git repository to a USB drive/stick and share it. In such cases, what you need is to create a bare repository so that all developers can collaborate and push their changes to it. Due to the distributed nature of the Git version control system, contents cannot be directly edited in the bare repository. The following more or less demonstrates the structure of a bare sharing repository (called sharing repository). 12345678910drwx------ 7 4,0K Apr 23 14:11 ./drwx------ 3 4,0K Apr 23 14:11 ../drwx------ 2 4,0K Apr 23 14:11 branches/drwx------ 2 4,0K Apr 23 14:11 hooks/drwx------ 2 4,0K Apr 23 14:11 info/drwx------ 4 4,0K Apr 23 14:11 objects/drwx------ 4 4,0K Apr 23 14:11 refs/-rw-r--r-- 1 104 Apr 23 14:11 config-rw-r--r-- 1 73 Apr 23 14:11 description-rw-r--r-- 1 23 Apr 23 14:11 HEAD Instead, users need to clone the bare sharing repository to create a local one (called working repository) with the following familiar structure. 123drwxrwxr-x 3 4,0K Apr 23 14:11 ./drwxrwxr-x 11 4,0K Apr 23 14:11 ../drwxrwxr-x 7 4,0K Apr 23 14:11 .git/ Having their own copies of the repository, users can now modify contents locally and push changes back to the sharing repository to make changes available to others. Creating a New Bare Sharing RepositoryCreating a new bare repository on your USB drive is as easy as follows: 1234cd /path/to/usb/stickmkdir &lt;repo-name&gt;.gitcd &lt;repo-name&gt;.gitgit init --bare Porting an Existing Working RepositoryIn case you want to create a bare sharing repository based on an existing working one, take the following steps: 1234567cd /path/to/usb/stickmkdir &lt;repo-name&gt;.gitcd /path/to/local/working/repository# create the bare repository by cloning the current onegit clone --bare --no-hardlinks . /path/to/usb/stick/&lt;repo-name&gt;.git# enable pushing to an alias instead of typing the whole URLgit remote add usbstick file:///path/to/usb/stick/&lt;repo-name&gt;.git Notice that according to Git documentations “–no-hardlinks” forces the cloning process from a repository on a local filesystem to copy the files under the .git/objects directory instead of using hardlinks. Testing Your Bare RepositoryAt this point developers can create their working repository by cloning the bare repository on the USB drive. 1git clone /path/to/usb/stick/&lt;repo-name&gt;.git /path/to/destination","categories":[{"name":"Dev. Tools","slug":"Dev-Tools","permalink":"http://truelogician.com/categories/Dev-Tools/"},{"name":"Git","slug":"Dev-Tools/Git","permalink":"http://truelogician.com/categories/Dev-Tools/Git/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Git","slug":"Git","permalink":"http://truelogician.com/tags/Git/"},{"name":"Version Control","slug":"Version-Control","permalink":"http://truelogician.com/tags/Version-Control/"},{"name":"Dev. Tools","slug":"Dev-Tools","permalink":"http://truelogician.com/tags/Dev-Tools/"}],"keywords":[{"name":"Dev. Tools","slug":"Dev-Tools","permalink":"http://truelogician.com/categories/Dev-Tools/"},{"name":"Git","slug":"Dev-Tools/Git","permalink":"http://truelogician.com/categories/Dev-Tools/Git/"}]},{"title":"Visitor Pattern","slug":"2013/visitor","date":"2013-11-21T21:01:56.000Z","updated":"2016-09-18T14:46:30.000Z","comments":true,"path":"2013/visitor/","link":"","permalink":"http://truelogician.com/2013/visitor/","excerpt":"Design Patterns Overview DefinitionDefine an Operation for One Family of Classes, Push Its Various Implementations to Another Family of Classes. The Former Is Called ‘Visitable’ or ‘Element’ and the Latter Is Known as ‘Visitor’.","text":"Design Patterns Overview DefinitionDefine an Operation for One Family of Classes, Push Its Various Implementations to Another Family of Classes. The Former Is Called ‘Visitable’ or ‘Element’ and the Latter Is Known as ‘Visitor’. Recipe The ‘Visitable’ is a simple class; perhaps with properties and/or behaviors. Yet it needs to provide a new functionality with logic which differs based on certain factors. Therefore, let’s push that logic for different implementations to different handlers. This is basically done by receiving the handler as part of the method signature. 123456interface IVisitable &#123; // contains some properties // the new functionality void accept(IVisitor visitor);&#125; As mentioned above, the reason for receiving the handler/visitor of the operation is to separate the logic from ‘Visitable’ and eventually use it as part of fulfilling the functionality ( visitor.visit(this) ). In other words, each handler might handle a visitable, interpret its properties or use its behaviors in a certain way (extracting implementations). 123456789class VisitableA implements IVisitable &#123; void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125;class VisitableB implements IVisitable &#123; void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125;class VisitableC implements IVisitable &#123; void accept(IVisitor visitor) &#123; visitor.visit(this); &#125;&#125; The ‘Visitor’ which contains the operation-logic on each and every ‘Visitable’. Notice that although the visitor/visitable return types are ‘void’, they are in fact arbitrary. They however must be known prior to implementation or we will face many changes. 12345678910111213141516interface IVisitor &#123; void visit(VisitableA visitableA); void visit(VisitableB visitableB); void visit(VisitableC visitableC);&#125;class VisitorX implements IVisitor &#123; void visit(VisitableA visitable) &#123;/*implementation*/&#125; void visit(VisitableB visitable) &#123;/*implementation*/&#125; void visit(VisitableC visitable) &#123;/*implementation*/&#125;&#125;class VisitorY implements IVisitor &#123; void visit(VisitableA visitable) &#123;/*implementation*/&#125; void visit(VisitableB visitable) &#123;/*implementation*/&#125; void visit(VisitableC visitable) &#123;/*implementation*/&#125;&#125; ServeHaving the ‘Visitable’ and the ‘Visitor’ ready, in order to run the operation, it’s now enough to pass the desired visitor to the visitable. 1234567891011class Client &#123; Client() &#123; IVisitor visitorX = new VisitorX(); IVisitor visitorY = new VisitorY(); IVisitable visitableC = new VisitableC(); visitableC.accept(visitorX); visitableC.accept(visitorY); &#125;&#125; Important Benefits Visitor pattern allows defining a new operation in ‘Visitable’ family with minimal changes in them. It pushes the operation’s logic to visitors and separates it from the visitable objects on which they operate. Note: Every time a new visitor is added, all existing visitors must provide support for it. In case there exist a lot of visitors/visitable classes, it might seem inconvenient over time as the system expands. ExampleA graphics software contains a set of definitions for geometrical shapes such as circle, rectangle, triangle and etc; each of which holds its own behaviors/specs. Imagine that you’re requested to provide various measurement information about them. measurements such as calculating surface, perimeter, finding shape’s center or etc. One way is to define measurements in the ‘IShape’ and implement them in the concrete classes.There is another way though, which is to extract these measurements logic to another family of classes.Let’s proceed with the latter approach and add the measuring functionality to all shapes. 1234567891011121314151617interface IShape &#123; // a shape's common behaviors &amp; specs double measure(IMeasurer visitor);&#125;class Circle implements IShape &#123; // circle specs like center &amp; radius double measure(IMeasurer m) &#123; return m.measure(this); &#125;&#125;class Rectangle implements IShape &#123; // rect specs like corner, width &amp; height double measure(IMeasurer m) &#123; return m.measure(this); &#125;&#125;class Triangle implements IShape &#123; // triangle specs like sides &amp; angles double measure(IMeasurer m) &#123; return m.measure(this); &#125;&#125; Let’s go ahead and define and implement logic for different types of measurements. Here, our calculation includes finding surface and perimeter amount. 12345678910111213141516interface IMeasurer &#123; double measure(Circle circle); double measure(Rectangle rectangle); double measure(Triangle triangle);&#125;class Surface implements IMeasurer &#123; double measure(Circle circle) &#123;/*return circle surface*/&#125; double measure(Rectangle rectangle) &#123;/*return rect surface*/&#125; double measure(Triangle triangle) &#123;/*return triangle surface*/&#125;&#125;class Perimeter implements IMeasurer &#123; double measure(Circle circle) &#123;/*return circle perimeter*/&#125; double measure(Rectangle rectangle) &#123;/*return rect perimeter*/&#125; double measure(Triangle triangle) &#123;/*return triangle perimeter*/&#125;&#125; Now, it’s possible to pass a measurer to a shape and ask for its calculation. 123456789101112class Client &#123; Client() &#123; IMeasurer surface = new Surface(); IMeasurer perimeter = new Perimeter(); IShape triangle = new Triangle(); IShape circle = new Circle(); double triangleSurface = triangle.measure(surface); double circlePerimeter = circle.measure(perimeter); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Memento Pattern","slug":"2013/memento","date":"2013-09-28T19:48:03.000Z","updated":"2016-09-18T14:49:10.000Z","comments":true,"path":"2013/memento/","link":"","permalink":"http://truelogician.com/2013/memento/","excerpt":"Design Patterns Overview DefinitionCreate a Restore Point to Revert Object State. Store an object’s state at some point in time in order to restore it later.","text":"Design Patterns Overview DefinitionCreate a Restore Point to Revert Object State. Store an object’s state at some point in time in order to restore it later. Recipe The ‘Memento’: Memento is an immutable object that holds a state. Think of it as a ‘Snapshot’ of the system state at a certain moment. 12345class Memento &#123; final Object state; Memento(Object state) &#123; this.state = state; &#125; Object getState() &#123; return state; &#125;&#125; The ‘Originator’: Originator also contains the state, but this is the current mutable state of the system. void setState(Object state): Overrides the system’s current state. Memento create(): Provides a snapshot of the system’s current state. Object restore(Memento memento): Returns the state of a certain snapshot. 123456class Originator &#123; Object state; void setState(Object state) &#123; this.state = state; &#125; Memento create() &#123; return new Memento(state); &#125; Object restore(Memento memento) &#123; return memento.getState(); &#125;&#125; The ‘Caretaker’: Caretaker acts as the memory required for maintaining a history of system’s saved snapshots. It’s possible to fetch or add (or perhapse remove) a snapshot. 12345class Caretaker &#123; List&lt;Memento&gt; mementos = new ArrayList&lt;&gt;(); void add(Memento memento) &#123; mementos.add(memento); &#125; Memento get(int index) &#123; return mementos.get(index); &#125;&#125; ServeSince none of the above entities goes under major chanes in production code, desinging a separate example seems almost redundant. Accordingly, the following client code is designed in a way to be both self-explanatory and stand for the pattern’s example. Imagine you’re about to create a simple text editor with undo/redo features. Also suppose that system saves a snapshot of the editor contents every two words. 12345678910111213141516171819202122232425262728293031323334353637class Client &#123; Client() &#123; Object state; Caretaker caretaker = new Caretaker(); Originator originator = new Originator(); originator.setState(\"This\"); originator.setState(\"This is\"); // save a snapshot of current state Memento memento1 = originator.create(); caretaker.add(memento1); System.out.println(\"[[STATE]]\"); System.out.println(memento1.getState() + \"\\n\"); originator.setState(\"This is a\"); originator.setState(\"This is a sentence.\"); // save a snapshot of current state Memento memento2 = originator.create(); caretaker.add(memento2); System.out.println(\"[[STATE]]\"); System.out.println(memento2.getState() + \"\\n\"); // undo to previous snapshot state = originator.restore(caretaker.get(0)); System.out.println(\"[[UNDO]]\"); System.out.println(state + \"\\n\"); // you might want to change current state originator.setState(state); // redo to latest snapshot state = originator.restore(caretaker.get(1)); System.out.println(\"[[REDO]]\"); System.out.println(state); // you might want to change current state originator.setState(state); &#125;&#125; Important BenefitsUsing this pattern allows for restoring an object’s state to one of its previous ones. Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Mediator Pattern","slug":"2013/mediator","date":"2013-08-18T05:04:36.000Z","updated":"2016-09-18T15:18:31.000Z","comments":true,"path":"2013/mediator/","link":"","permalink":"http://truelogician.com/2013/mediator/","excerpt":"Design Patterns Overview DefinitionProvide an Interaction-Contract object Called Mediator for a Group of Colleagues/components. Centralize Communications Among Colleagues/components Without Them Knowing Even About Each Other’s Existence. In Other Words, Centralize Complex Communications and Control Between Related Objects.","text":"Design Patterns Overview DefinitionProvide an Interaction-Contract object Called Mediator for a Group of Colleagues/components. Centralize Communications Among Colleagues/components Without Them Knowing Even About Each Other’s Existence. In Other Words, Centralize Complex Communications and Control Between Related Objects. Recipe The ‘Mediator’ definition which is actually a “Contract of Interaction” It could keep a collection of components/colleagues to communicate their interactions. Behaviors could also accept a reference to the requester to enhance the logic. Behaviors could define as much arguments as required for implementation. 123456789101112abstract class Mediator &#123; /*optionally maintaining a collection of colleagues*/ Collection&lt;Colleague&gt; colleagues; void add(Colleague colleague) &#123;/* add to colleagues */&#125; void rem(Colleague colleague) &#123;/*remove from colleagues*/&#125; /*defining 'requester' argument is also arbitrary*/ abstract void operation1(Colleague requester/*, args */); abstract void operation2(Colleague requester/*, args */); abstract void operation3(Colleague requester/*, args */); abstract void operation4(Colleague requester/*, args */);&#125; Concrete implementations of mediator. 123456789101112131415161718192021class MediatorX extends Mediator &#123; void operation1(Colleague requester/*, args */) &#123;/*implementation*/&#125; void operation2(Colleague requester/*, args */) &#123;/*implementation*/&#125; void operation3(Colleague requester/*, args */) &#123;/*implementation*/&#125; void operation4(Colleague requester/*, args */) &#123;/*implementation*/&#125;&#125;class MediatorY extends Mediator &#123; void operation1(Colleague requester/*, args */) &#123;/*implementation*/&#125; void operation2(Colleague requester/*, args */) &#123;/*implementation*/&#125; void operation3(Colleague requester/*, args */) &#123;/*implementation*/&#125; void operation4(Colleague requester/*, args */) &#123;/*implementation*/&#125;&#125; The Colleague/Component concept and concrete implementations. Note that a colleagues has a reference to the mediator to delegate its activities. Can also be designed in a way to set/change their mediators at runtime. Remember to pull up identical method implementations from concrete classes. 123456789101112131415161718abstract class Colleague &#123; Mediator mediator; void setMediator(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125;class ColleagueA extends Colleague &#123; /*colleague delegates its actions to the mediator*/ void action1() &#123; mediator.operation1(this); &#125; void action2() &#123; mediator.operation2(this); &#125;&#125;class ColleagueB extends Colleague &#123; /*colleague delegates its actions to the mediator*/ void action3() &#123; mediator.operation3(this); &#125; void action4() &#123; mediator.operation4(this); &#125;&#125; ServeNow that the mediator and colleagues are defined, it only suffices to: Introduce mediator to colleagues. Introduce colleagues to mediator. Ask colleagues for their provided behaviors. 12345678910111213141516171819202122232425class Client &#123; Client() &#123; Mediator mediatorX = new MediatorX(); ColleagueA a1 = new ColleagueA(); ColleagueA a2 = new ColleagueA(); ColleagueB b1 = new ColleagueB(); ColleagueB b2 = new ColleagueB(); /*introduce mediator to colleagues*/ a1.setMediator(mediatorX); a1.setMediator(mediatorX); b1.setMediator(mediatorX); b2.setMediator(mediatorX); /*introduce colleagues to mediator*/ mediatorX.add(a1); mediatorX.add(a2); mediatorX.add(b1); mediatorX.add(b2); a1.action2(); a2.action1(); b1.action4(); b2.action3(); &#125;&#125; Important Benefits Mediator promotes loose coupling by: Keeping objects from referring to each other explicitly Encapsulating the interaction and communication. It allows modifications to colleagues interaction independently. ExampleBased on the logic, the mediator can contain a collection of colleagues used as part of the logic (example), however in the following example, for the sake of clarity and stressing more on the role of mediators and colleagues, we will skip maintaining such list. Suppose you’re about to write a module to provide joystick functionalities for a few games; in a way that a set of different controller devices can be connected to a various games, enabling players to play them. Accordingly, let’s first define the game base functionalities and their implementations in each specific game. 1234567891011121314151617181920212223242526interface IMediator &#123; void fire(); void forward(double intensity); void backward(double intensity); void left(double intensity); void right(double intensity); void quit();&#125;class NeedForSpeed implements IMediator &#123; void fire() &#123;/*activate nitro mode*/&#125; void forward(double intensity) &#123;/*speed up*/&#125; void backward(double intensity) &#123;/*slow down*/&#125; void left(double intensity) &#123;/*turn wheel left*/&#125; void right(double intensity) &#123;/*turn wheel right*/&#125; void quit() &#123;/*quit game*/&#125;&#125;class CallOfDuty implements IMediator &#123; void fire() &#123;/*fire current weapon*/&#125; void forward(double intensity) &#123;/*move forward*/&#125; void backward(double intensity) &#123;/*move backward*/&#125; void left(double intensity) &#123;/*move left*/&#125; void right(double intensity) &#123;/*move right*/&#125; void quit() &#123;/*quit game*/&#125;&#125; The colleagues are the controller devices to be connected to games later on. 123456789101112131415161718192021abstract class Colleague &#123; IMediator mediator; void setMediator(IMediator mediator) &#123; this.mediator = mediator; &#125;&#125;class RightTrigger extends Colleague &#123; void press() &#123; mediator.fire(); &#125;&#125;class LeftBumper extends Colleague &#123; void press() &#123; mediator.quit(); &#125;&#125;class DPad extends Colleague &#123; void up(double intensity) &#123; mediator.forward(intensity); &#125; void down(double intensity) &#123; mediator.backward(intensity); &#125; void right(double intensity) &#123; mediator.left(intensity); &#125; void left(double intensity) &#123; mediator.right(intensity); &#125;&#125; Now that games and controllers are ready: Instantiate controllers and a game. Assign controllers to a specific game. Use controllers to play. 123456789101112131415161718192021222324252627282930313233343536class Client &#123; Client() &#123; DPad dPad = new DPad(); RightTrigger fire = new RightTrigger(); LeftBumper quit = new LeftBumper(); IMediator callOfDuty = new CallOfDuty(); dPad.setMediator(callOfDuty); fire.setMediator(callOfDuty); quit.setMediator(callOfDuty); dPad.up(2.2); dPad.up(2.2); dPad.up(8.9); fire.press(); fire.press(); dPad.left(3); quit.press(); /*let's change the game*/ IMediator needForSpeed = new NeedForSpeed(); dPad.setMediator(needForSpeed); fire.setMediator(needForSpeed); quit.setMediator(needForSpeed); dPad.up(9.3); dPad.up(9.6); dPad.up(9.9); fire.press(); dPad.left(4); dPad.right(1); quit.press(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Interpreter Pattern","slug":"2013/interpreter","date":"2013-07-03T17:15:28.000Z","updated":"2016-09-18T15:16:35.000Z","comments":true,"path":"2013/interpreter/","link":"","permalink":"http://truelogician.com/2013/interpreter/","excerpt":"Design Patterns Overview DefinitionMap, Translate or Interpret a Given Data Into Different Formats. It Converts One Representation of Data to Another; Very Much Like a Language Interpreter.","text":"Design Patterns Overview DefinitionMap, Translate or Interpret a Given Data Into Different Formats. It Converts One Representation of Data to Another; Very Much Like a Language Interpreter. This piece of data that is interpreted to different representations is called ‘Context’. Recipe The definition of ‘Expression’. An expression contains methods to interpret a given ‘Context’ to other expressions. Note that ‘Context’ is of type ‘Object’ but it’s type or definition is arbitrary. 12345interface Expression &#123; Object toExpA(Object context); Object toExpB(Object context); Object toExpC(Object context);&#125; Concrete expressions.Note that methods ‘toExpA’, ‘toExpB’ and ‘toExpC’ do not return an object of type ‘ExpA’, ‘ExpB’ or ‘ExpC’, since expressions are merely converters. 123456789101112131415class ExpA implements Expression &#123; Object toExpA(Object context) &#123;/*implementation*/&#125; Object toExpB(Object context) &#123;/*implementation*/&#125; Object toExpC(Object context) &#123;/*implementation*/&#125;&#125;class ExpB implements Expression &#123; Object toExpA(Object context) &#123;/*implementation*/&#125; Object toExpB(Object context) &#123;/*implementation*/&#125; Object toExpC(Object context) &#123;/*implementation*/&#125;&#125;class ExpC implements Expression &#123; Object toExpA(Object context) &#123;/*implementation*/&#125; Object toExpB(Object context) &#123;/*implementation*/&#125; Object toExpC(Object context) &#123;/*implementation*/&#125;&#125; ServeNow that it’s possible to convert every expression to one another, the client only needs to create a context that can be interpreted by an expression and pass it along to end up with a different format. 1234567891011121314151617class Client &#123; Client() &#123; Object contextA = new Object(); Object contextB = new Object(); Object contextC = new Object(); Object formatA, formatB, formatC; formatB = new ExpA().toExpB(contextA); formatC = new ExpA().toExpC(contextA); formatA = new ExpB().toExpA(contextB); formatC = new ExpB().toExpC(contextB); formatA = new ExpC().toExpA(contextC); formatB = new ExpC().toExpB(contextC); &#125;&#125; Important BenefitsThis pattern provides a framework for interpretation of the data or complex grammar along with abstraction and loose coupling. ExampleSuppose you are responsible for writing a module which is responsible for translating and forwarding messages sent by these services. For instance, if the module receives a XML SOAP request, it shall translate it to a simple TCP request and send it to the TCP server.These services consist of: A REST service. A TCP server. A SOAP service. There is also a logger to log the events in Json format. The ‘Expression’ interface contains all kinds of desired conversions. 123456interface Expression &#123; Object toBytes(Object context); String toXml(Object context); String toUri(Object context); String toJson(Object context);&#125; Each concrete expression assumes receiving a ‘Context’ of its type and implement conversion to other formats. 123456789101112131415161718192021222324class XmlExpression implements Expression &#123; byte[] toBytes(Object context) &#123; return /*from xml to byte[]*/; &#125; String toXml(Object context) &#123; return (String) context; &#125; String toUri(Object context) &#123; return /*from xml to uri*/; &#125; String toJson(Object context) &#123; return /*from xml to json*/; &#125;&#125;class UriExpression implements Expression &#123; byte[] toBytes(Object context) &#123; return /*from uri to byte[]*/; &#125; String toXml(Object context) &#123; return /*from uri to xml*/; &#125; String toUri(Object context) &#123; return (String) context; &#125; String toJson(Object context) &#123; return /*from uri to json*/; &#125;&#125;class JsonExpression implements Expression &#123; byte[] toBytes(Object context) &#123; return /*from json to byte[]*/; &#125; String toXml(Object context) &#123; return /*from json to xml*/; &#125; String toUri(Object context) &#123; return /*from json to uri*/; &#125; String toJson(Object context) &#123; return (String) context; &#125;&#125;class BytesExpression implements Expression &#123; byte[] toBytes(Object context) &#123; return (byte[]) context; &#125; String toXml(Object context) &#123; return /*from byte[] to xml*/; &#125; String toUri(Object context) &#123; return /*from byte[] to uri*/; &#125; String toJson(Object context) &#123; return /*from byte[] to json*/; &#125;&#125; Lines 3-8 is when a byte stream needs to be logged and then translated to a REST resource URI. Lines 10-13 is when a SOAP XML request is received and shall be logged and forwarded to the TCP server. 123456789101112131415class Client &#123; Client() &#123; byte[] stream = new byte[1024]; // log json presentation of the stream content Logger.log(new BytesExpression().toJson(stream)); // get REST resource by uri String uri = new BytesExpression().toUri(stream); WebResource resource = client.resource(uri); String xml = \"&lt;order&gt;&lt;item name=\\\"Hamlet\\\" /&gt;&lt;/order&gt;\"; Logger.log(new XmlExpression().toJson(xml)); // send xml data to a TCP sever as byte[] tcpClient.send(new XmlExpression().toBytes(xml)); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Chain of Responsibility Pattern","slug":"2013/chain","date":"2013-05-03T17:15:28.000Z","updated":"2017-01-09T08:44:15.000Z","comments":true,"path":"2013/chain/","link":"","permalink":"http://truelogician.com/2013/chain/","excerpt":"Design Patterns Overview DefinitionPass a Product to a Chain of Processors and Each Will Do Its Job.","text":"Design Patterns Overview DefinitionPass a Product to a Chain of Processors and Each Will Do Its Job. Recipe Define your ‘Product’ how ever you want. 1class Product &#123;/*implementation*/&#125; A chain is created out of links which satisfy at least 2 basic behaviors. They can process a given ‘Product’ object. They know about the next link in the chain. 1234interface ILink &#123; void process(Product product); void setNextLink(ILink link);&#125; Now let’s define a few links for our chain; each of which might or might not process the passed product. 1234567891011121314151617181920212223242526class LinkA implements ILink &#123; ILink nextLink; public void setNextLink(ILink link) &#123; nextLink = link; &#125; public void process(Product product) &#123; /* perform process 'A' on the product. or not! */ if (nextLink != null) nextLink.process(product); &#125;&#125;class LinkB implements ILink &#123; ILink nextLink; public void setNextLink(ILink link) &#123; nextLink = link; &#125; public void process(Product product) &#123; /* perform process 'B' on the product. or not! */ if (nextLink != null) nextLink.process(product); &#125;&#125;class LinkC implements ILink &#123; ILink nextLink; public void setNextLink(ILink link) &#123; nextLink = link; &#125; public void process(Product product) &#123; /* perform process 'C' on the product. or not! */ if (nextLink != null) nextLink.process(product); &#125;&#125; ServeNow that the product and the chain links exist, the client needs only to weave the links together to make a chain and pass a product to its first link. 123456789101112131415class Client &#123; Client() &#123; ILink linkA = new LinkA(); ILink linkB = new LinkB(); ILink linkC = new LinkC(); /* creating a chain by introducing * the next link of each link. */ linkA.setNextLink(linkB); linkB.setNextLink(linkC); linkA.process(new Product()); &#125;&#125; Important BenefitsThis pattern decouples commands/handlers (e.g ‘Link’) and allows them to have their own independent logic. ExampleSuppose that you’re developing a module for the local post office to send out notifications to recipients when they receive a package. This notification message shall be sent by mail, sms and email. Accordingly our Message object could be designed as follows. 123456class Message &#123; String notificationContent; String recipientPhone; String recipientMail; String recipientAddress;&#125; The chain’s ‘Link’ interface is called ‘INotification’ and each implementation contains logic to send a message in a specific way. 12345678910111213141516171819202122232425262728293031interface INotification &#123; void setNext(INotification n); void send(Message message);&#125;class Sms implements INotification &#123; INotification next; public void setNext(INotification n) &#123; next = n; &#125; public void send(Message message) &#123; /* send a SMS message to the given number */ if (next != null) next.send(message); &#125;&#125;class Email implements INotification &#123; INotification next; public void setNext(INotification n) &#123; next = n; &#125; public void send(Message message) &#123; /* send an email to the given mail address */ if (next != null) next.send(message); &#125;&#125;class Post implements INotification &#123; INotification next; public void setNext(INotification n) &#123; next = n; &#125; public void send(Message message) &#123; /* print &amp; mail to the given postal address */ if (next != null) next.send(message); &#125;&#125; The client instantiates and links the notifiers to create a chain and finally passes the message to the first link of the chain. 1234567891011121314class Client &#123; Client() &#123; INotification sms = new Sms(); INotification mail = new Email(); INotification post = new Post(); sms.setNext(mail); mail.setNext(post); Message message = new Message(); /* set message properties to math recipient */ sms.send(message); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"State Pattern","slug":"2013/state","date":"2013-03-29T16:51:03.000Z","updated":"2016-09-18T14:47:41.000Z","comments":true,"path":"2013/state/","link":"","permalink":"http://truelogician.com/2013/state/","excerpt":"Design Patterns Overview DefinitionChange the Behavior According to the State. Encapsulate State-Based Behaviors and Use Delegation to Switch Between Behaviors.","text":"Design Patterns Overview DefinitionChange the Behavior According to the State. Encapsulate State-Based Behaviors and Use Delegation to Switch Between Behaviors. Using this pattern you can create a static state machine. What is a State Machine? One of the most concise definitions can be found in Oxford Dictionaries web page. A state machine is a device which can be in one of a set number of stable conditions depending on its previous condition and on the present values of its inputs. Recipe The definition of ‘State’. A state can be asked to make transitions to other states. The following state definition; for instance, can make up to 3 transitions. 12345interface IState &#123; void makeTransition1(); void makeTransition2(); void makeTransition3();&#125; The definition of a ‘StateMachine’ (aka Context). In our case it can only be in stateA or stateB. Note that in order to improve code clarity I’ve grouped methods into two sets: Those intended to be used by states: These methods only change the machine’s current state. Those intended to be used by clients: These methods ask current state for a certain transition. 123456789101112131415class StateMachine &#123; IState stateA; IState stateB; IState currentState; /* used by client */ void action1() &#123; currentState.makeTransition1(); &#125; void action2() &#123; currentState.makeTransition2(); &#125; void action3() &#123; currentState.makeTransition3(); &#125; /* used by states */ void gotoStateA() &#123; currentState = stateA; &#125; void gotoStateB() &#123; currentState = stateB; &#125;&#125; Concrete implementations of the ‘State’. Notice that they can access the state machine on which they operate. For each of their transitions, they define next state of the machine. 12345678910111213class StateA implements IState &#123; StateMachine machine; void makeTransition1() &#123; machine.gotoStateA(); &#125; void makeTransition2() &#123; machine.gotoStateB(); &#125; void makeTransition3() &#123; machine.gotoStateB(); &#125;&#125;class StateB implements IState &#123; StateMachine machine; void makeTransition1() &#123; machine.gotoStateA(); &#125; void makeTransition2() &#123; machine.gotoStateB(); &#125; void makeTransition3() &#123; machine.gotoStateA(); &#125;&#125; ServeThe state pattern client can only access the state machine’s actions. Accordingly, the machine will take over corresponding states. 12345678910class Client &#123; Client() &#123; StateMachine machine = new StateMachine(); machine.action3(); machine.action1(); machine.action2(); machine.action1(); machine.action2(); &#125;&#125; Important BenefitsCreating a clean implementation of a state machine together with states and transitions. ExampleLet’s implement the Wikipedia’s example of a state machine. Before going through the code take look at its state diagram to understand the involved states and transitions. According to the diagram, there are two possible transitions: inserting a coin or pushing the handle. As a result, our definition of a state will look like this: 12345678910interface IState &#123; void coin(); void push();&#125;abstract class State implements IState &#123; protected final Turnstile machine; public State(Turnstile machine) &#123; this.machine = machine; &#125;&#125; Our turnstile state machine contains two states and provides appropriate methods for clients and also the states. 1234567891011121314class Turnstile &#123; private IState locked = new Locked(this); private IState unlocked = new Unlocked(this); private IState currentState = locked; /* used by client */ public void insertCoin() &#123; currentState.coin(); &#125; public void pushHandle() &#123; currentState.push(); &#125; /* used by states */ void gotoUnlocked() &#123; currentState = unlocked; &#125; void gotoLocked() &#123; currentState = locked; &#125;&#125; The locked and unlocked states both determine turnstile’s next state based on the transition. 123456789101112131415class Locked extends State &#123; public Locked(Turnstile machine) &#123; super(machine); &#125; public void coin() &#123; machine.gotoUnlocked(); &#125; public void push() &#123;&#125;&#125;class Unlocked extends State &#123; public Unlocked(Turnstile machine) &#123; super(machine); &#125; public void coin() &#123;&#125; public void push() &#123; machine.gotoLocked(); &#125;&#125; Finally, a client can create a turnstile, invoke any of the two available behaviors and watch the state changes accordingly. 1234567891011class Client &#123; Client() &#123; Turnstile turnstile = new Turnstile(); turnstile.pushHandle(); turnstile.insertCoin(); turnstile.pushHandle(); turnstile.pushHandle(); turnstile.insertCoin(); turnstile.pushHandle(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Proxy Pattern (Protection Proxy)","slug":"2012/proxy","date":"2012-11-09T17:11:26.000Z","updated":"2016-09-18T15:06:28.000Z","comments":true,"path":"2012/proxy/","link":"","permalink":"http://truelogician.com/2012/proxy/","excerpt":"Design Patterns Overview DefinitionLimit Access to a Sensitive Class’s Properties and Behaviors. Wraps an Object In Order to Control Access to It.","text":"Design Patterns Overview DefinitionLimit Access to a Sensitive Class’s Properties and Behaviors. Wraps an Object In Order to Control Access to It. Proxy pattern come in three variations; Remote, Virtual and Protection. Although they are the same in essence, the following introduction discusses the Protection proxy pattern. You can read more about Remote and Virtual Proxies on Wikipedia. Recipe As usual let’s start with the definition of a Product and its concrete class (real object). 123456789101112interface IProduct &#123; Object getSensitiveData(); void sensitiveActionA(); void normalOperationB();&#125;class Product implements IProduct &#123; public Object getSensitiveData() &#123;return /*data*/;&#125; public void sensitiveActionA() &#123;/*implementation*/&#125; public void normalOperationB() &#123;/*implementation*/&#125;&#125; Since ‘Product’ contains sensitive information, we need to define the ‘Proxy’. Only the ‘Proxy’ is exposed to the outside world. It might only provide insensitive information. It can restrict the use of sensitive operations. 12345678910111213141516interface IProxy &#123; void operationB(); void operationC();&#125;class ProxyProduct implements IProxy &#123; Product product = new Product(); public void operationB() &#123; product.normalOperationB(); &#125; public void operationC() &#123; /*security conditions &amp; restrictions*/ product.sensitiveActionA(); &#125;&#125; ServeSince the client code has only access to the ‘ProxyProduct’, it can only use the insensitive or restricted operations. 1234567class Client &#123; Client() &#123; IProxy proxy = new ProxyProduct(); proxy.operationB(); proxy.operationC(); &#125;&#125; Important BenefitsUsing this pattern the sensitive class’s properties and behaviors are secured. ExampleSuppose a software module implements a way to interact with the underlying OS. However, out of this module scope (aka package or namespace), the clients of this module shall not be able to run certain group of commands. The following is the core interaction part to which the clients have no access. 12345class Shell &#123; public void run(ICommand command) &#123; /*implementation*/ &#125;&#125; The Command are categorized into 2 groups of: SYS Commands: The sensitive commands that are run by clients within the scope. NET Commands: The regular simple commands which can be run by all clients. 12345678910111213141516interface ICommand &#123; String get(); &#125;interface ISysCommand extends ICommand &#123;&#125;interface INetCommand extends ICommand &#123;&#125;class Reboot implements ISysCommand &#123; public String get() &#123; return \"sudo reboot\"; &#125;&#125;class Shutdown implements ISysCommand &#123; public String get() &#123; return \"sudo shutdown -h now\"; &#125;&#125;class Ping implements INetCommand &#123; public String get() &#123; return \"ping -c 3\"; &#125;&#125;class Ip implements INetCommand &#123; public String get() &#123; return \"ifconfig eth0\"; &#125;&#125; The proxy and its concrete implementation are the only means for outside-scope clients to interact with OS. The proxy, in this case, filters out all system commands. 123456789101112interface IProxy &#123; void run(ICommand command) throws Exception;&#125;class ShellProxy implements IProxy &#123; Shell shell = new Shell(); public void run(ICommand command) throws Exception &#123; if (command instanceof ISysCommand) throw new Exception(\"cannot run system commands\"); shell.run(command); &#125;&#125; and finally, the client code that is only allowed to execute simple networking commands. 1234567891011class Client &#123; Client() &#123; ShellProxy shellProxy = new ShellProxy(); try &#123; shellProxy.run(new Ping()); shellProxy.run(new Reboot()); &#125; catch (Exception e) &#123; System.out.println(\"Error: \" + e.getMessage()); &#125; &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}]},{"title":"Replacing Conditionals with Patterns","slug":"2012/conditionals","date":"2012-10-18T15:14:36.000Z","updated":"2016-10-03T21:27:01.000Z","comments":true,"path":"2012/conditionals/","link":"","permalink":"http://truelogician.com/2012/conditionals/","excerpt":"Since switches and if-statements are the most common control flow statements in many languages and are widely used throughout the code, removing the unnecessarily used ones will have a huge impact on the general readability of the code.","text":"Since switches and if-statements are the most common control flow statements in many languages and are widely used throughout the code, removing the unnecessarily used ones will have a huge impact on the general readability of the code. Use Null-Object PatternAlways try not to return null references, instead practice the Null-Object Pattern and return Null-Objects that are neutral to operations and processes. Suppose a module is responsible for specific calculations for a person’s properties on which taxes are paid. 123456789101112131415161718192021class PropertyTaxCalculator &#123; void calculate(String personId) &#123; Person person = getPerson(personId); if (person != null) &#123; TaxPayments taxPayments = person.getTaxPayments(2012); if (taxPayments != null) &#123; PropertyTax propertyTax = taxPayments.get(PROPERTY_TAX); if (propertyTax != null) &#123; List&lt;Property&gt; properties = propertyTax.getProperties(); if (properties != null) &#123; for(Property property : properties) &#123; if (property != null) &#123; // do the main calculations here &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; The snippet below does the same using Null-Object Pattern. Notice how applying this pattern removes the necessity for excessive null checks in the second revision of the ‘PropertyTaxCalculator’. 1234567891011121314class PropertyTaxCalculator &#123; void calculate(String personId) &#123; List&lt;Property&gt; properties = getPerson(personId) .getTaxPayments(2012) .get(PROPERTY_TAX) .getProperties(); for(Property property : properties) &#123; // do the main calculations here &#125; &#125;&#125; Use Strategy PatternStrategy Pattern is another tool in the belt to get rid of conditional statements. The following pseudo-code demonstrates an example where an operation happens on an object based on a specific condition (the client ‘type’ in our example). 123456789101112class Client &#123; Type type; void process(Object object) &#123; if (type == TypeA) &#123; operationA(object); &#125; else if (type == TypeB) &#123; operationB(object); &#125; else if (type == TypeC) &#123; operationC(object); &#125; &#125;&#125; Since the client has a certain type at each moment, we can move the logic in each leg of the conditionals to a different strategy implementation. 1234567891011121314151617181920212223242526272829303132class Client &#123; IStrategy strategy; void process(Object object) &#123; strategy.process(object); &#125;&#125;interface IStrategy &#123; void process(Object object);&#125;class StrategyA implements IStrategy &#123; public void process(Object object) &#123; operationA(object); &#125;&#125;class StrategyB implements IStrategy &#123; public void process(Object object) &#123; operationB(object); &#125;&#125;class StrategyC implements IStrategy &#123; public void process(Object object) &#123; operationC(object); &#125;&#125;// a newly added conditionclass StrategyD implements IStrategy &#123; public void process(Object object) &#123; operationD(object); &#125;&#125; It might look like using the strategy we ended up with twice as much code, however, the separation of concerns into different classes, encourages single responsibility and at the same time it makes them more readable and more testable. Besides, note that new conditions can be added without the need for modifying the client code. Use Factory-Method PatternIn case of encountering repeated conditionals that are used for object instantiation, the Factory-Method Pattern might be useful. The pseudo-code below might look a bit long but it basically defines two behaviors each of which needs a ‘Product’ which is instantiated conditionally. 1234567891011121314151617181920212223242526class Client &#123; Type type; void action1() &#123; IProduct product = null; if (type == TypeA) &#123; product = new ProductA(); &#125; else if (type == TypeB) &#123; product = new ProductB(); &#125; else if (type == TypeC) &#123; product = new ProductC(); &#125; operation1(product); &#125; void action2() &#123; IProduct product = null; if (type == TypeA) &#123; product = new ProductA(); &#125; else if (type == TypeB) &#123; product = new ProductB(); &#125; else if (type == TypeC) &#123; product = new ProductC(); &#125; operation2(product); &#125;&#125; Such repeating conditional object instantiation is a sign of need for refactoring into Factory-Method Pattern as suggested below. 1234567891011121314151617181920class Client &#123; Type type; void action1() &#123; operation1(ProductFactory.create(type)); &#125; void action2() &#123; operation2(ProductFactory.create(type)); &#125;&#125;class ProductFactory &#123; static IProduct create(Type type) &#123; switch (type) &#123; case TypeA: return new ProductA(); case TypeB: return new ProductB(); case TypeC: return new ProductC(); default: return new NullProduct(); &#125; &#125;&#125; ConclusionAlthough it might not be necessary nor feasible to get rid of many of the conditionals (such as when comparing primitive objects or enums), most unnecessary ones can be replaced by polymorphism and patterns which will improve code readability, testability and advocates separation of concerns.","categories":[{"name":"Object-Oriented Design","slug":"Object-Oriented-Design","permalink":"http://truelogician.com/categories/Object-Oriented-Design/"},{"name":"Software Craftsmanship","slug":"Object-Oriented-Design/Software-Craftsmanship","permalink":"http://truelogician.com/categories/Object-Oriented-Design/Software-Craftsmanship/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Object-Oriented Design","slug":"Object-Oriented-Design","permalink":"http://truelogician.com/tags/Object-Oriented-Design/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://truelogician.com/tags/Clean-Code/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://truelogician.com/tags/Refactoring/"},{"name":"Design for Testability","slug":"Design-for-Testability","permalink":"http://truelogician.com/tags/Design-for-Testability/"},{"name":"Single Responsibility","slug":"Single-Responsibility","permalink":"http://truelogician.com/tags/Single-Responsibility/"},{"name":"Separation of Concerns","slug":"Separation-of-Concerns","permalink":"http://truelogician.com/tags/Separation-of-Concerns/"},{"name":"Replacing Conditionals","slug":"Replacing-Conditionals","permalink":"http://truelogician.com/tags/Replacing-Conditionals/"}],"keywords":[{"name":"Object-Oriented Design","slug":"Object-Oriented-Design","permalink":"http://truelogician.com/categories/Object-Oriented-Design/"},{"name":"Software Craftsmanship","slug":"Object-Oriented-Design/Software-Craftsmanship","permalink":"http://truelogician.com/categories/Object-Oriented-Design/Software-Craftsmanship/"}]},{"title":"Flyweight Pattern","slug":"2012/flyweight","date":"2012-09-23T21:21:17.000Z","updated":"2016-09-18T15:02:01.000Z","comments":true,"path":"2012/flyweight/","link":"","permalink":"http://truelogician.com/2012/flyweight/","excerpt":"Design Patterns Overview DefinitionImprove Performance by Sharing Objects Instead of Creating Them.","text":"Design Patterns Overview DefinitionImprove Performance by Sharing Objects Instead of Creating Them. RecipeBefore identifying the elements for flyweight pattern, consider the following definitions: Intrinsic State: A state in the object upon which we will keep a reference of that object (share the object). Extrinsic State: Other states of the object that are not important to your activity at all. 123456789interface IProduct &#123;&#125;class Product implements IProduct &#123; Object intrinsicState; /* extrinsic states... */ Product(Object intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125;&#125; The factory where limited objects are kept and can be fetched by their intrinsic state. 123456789class ProductFactory &#123; static HashMap&lt;Object, IProduct&gt; products = new HashMap&lt;&gt;(); static IProduct create(Object intrinsicState) &#123; if (!products.containsKey(intrinsicState)) products.put(intrinsicState, new Product(intrinsicState)); return products.get(intrinsicState); &#125;&#125; ServeThe client uses the factory to either create or fetch previously created product. The client can change any extrinsic states of the same instance of the fetched product and use it as suited. 12345678910class Client &#123; List&lt;IProduct&gt; products = new Vector&lt;&gt;(); Client() &#123; for (int i = 0; i &lt; 100000; i++) &#123; Object intrinsicState = getFromLimitedIntrinsicStates(); products.add(ProductFactory.create(intrinsicState)); &#125; &#125;&#125; Important BenefitsThis pattern reduces the amount of memory consumption by sharing the objects that are similar in some way rather than creating new ones. ExampleA governmental application shall be put to smoke test for it’s limitations while processing massive amount of data. Your task is to create an in-memory database (Collections) with many records to make the test closer to reality. This collection does not need to contain unique items as long as it contains many of them. Imagine this in-memory database table called ‘JobsTable’ that needs to be populated with at least around 100,000 ‘Job’ object. Let’s first define the notion of ‘Job’ and ‘MockJob’. Notice that job title is the Job’s intrinsic state of the ‘Job’. 123456789101112interface IJob &#123;&#125;class MockJob implements IJob &#123; String title; double salary; String risk; MockJob(String title) &#123; this.title = title; salary = 1000d; risk = \"LOW\"; &#125;&#125; The ‘JobFactory’ stores jobs based on their title. We will end up with limited amount of instances in memory. 1234567891011class JobFactory &#123; static HashMap&lt;String, IJob&gt; jobs; static IJob create(String title) &#123; if (jobs.containsKey(title)) return jobs.get(title); IJob job = new MockJob(title); jobs.put(title, job); return job; &#125;&#125; The database table implementation, in our example, which keeps references to those limited instances in a ‘Vector’. 1234567class JobsTable &#123; List&lt;IJob&gt; jobs = new Vector&lt;&gt;(); void addJob(String title) &#123; jobs.add(JobFactory.create(title)); &#125;&#125; Finally, our unit test will look something like this. 1234567891011121314151617181920class TestClass &#123; SystemUnderTest sut; void smokeTest() &#123; JobsTable table = new JobsTable(); for (int i = 0; i &lt; 1000000; i++) &#123; String title = getRandomTitle(); table.addJob(title); &#125; sut.process(table); &#125; String[] titles = new String[] &#123; \"Engineer\", \"Doctor\", \"Worker\", \"Teacher\" &#125;; String getRandomTitle() &#123; return // a random title from the titles array; &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}]},{"title":"Composite Pattern","slug":"2012/composite","date":"2012-06-14T19:19:03.000Z","updated":"2016-09-18T14:59:52.000Z","comments":true,"path":"2012/composite/","link":"","permalink":"http://truelogician.com/2012/composite/","excerpt":"Design Patterns Overview DefinitionAdd the Capability of Never Ending Grouping. Client Treats Collection of Objects and Individual Objects Uniformly.","text":"Design Patterns Overview DefinitionAdd the Capability of Never Ending Grouping. Client Treats Collection of Objects and Individual Objects Uniformly. Recipe Imagine the famous example of ‘Leaf’ and ‘Branch’ A ‘Branch’ can contain other more branches or leaves. A ‘Leaf’ cannot contain any other leaf or branch. Now let’s define a single ‘Leaf’ (‘IProduct’ in this case). 1234interface IProduct &#123; void operationA(); void operationB();&#125; The implementation of the atomic ‘Leaf’ entity (Product). The implementation of the non-atomic ‘Branch’ (ProductGroup). Notice that ProductGroup implements the same interface and contains a collection of products at the same time. 1234567891011121314class Product implements IProduct &#123; public void operationA() &#123;/*implementation*/&#125; public void operationB() &#123;/*implementation*/&#125;&#125;class ProductGroup implements IProduct &#123; List&lt;IProduct&gt; products; public void add(IProduct... product) &#123;/*add to products*/&#125; public void remove(IProduct product) &#123;/*remove form products*/&#125; public void operationA() &#123;/*implementation*/&#125; public void operationB() &#123;/*implementation*/&#125;&#125; ServeAfter having the ‘Leaf’ and ‘Branch’ implementations in place, the client can now compose the tree and treat branches or leaves uniformly. 12345678910111213141516171819202122class Client &#123; Client() &#123; ProductGroup groupA = new ProductGroup(); ProductGroup groupA1 = new ProductGroup(); ProductGroup groupA2 = new ProductGroup(); ProductGroup groupB = new ProductGroup(); ProductGroup groupB1 = new ProductGroup(); IProduct product1 = new Product(); IProduct product2 = new Product(); groupA.add(groupA1, groupA2); groupB.add(groupB1); ProductGroup allGroups = new ProductGroup(); allGroups.add(groupA, groupB, product1, product2); allGroups.operationA(); product1.operationA(); &#125;&#125; Important Benefits Allows treating individual objects and compositions uniformly. ExampleImagine your company asked you to create utility classes for the organizational chart.The ‘WestCoast’ organization contains multiple divisions and departments. Each division might consist of other divisions or departments that groups them together. It is required to provide ceratin functionalities for handling employees and staff within divisions and departments. The notion of ‘Department’ is the atomic entity or a ‘Leaf’ The notion of ‘Division’ is the composite entity or a ‘Branch’ Don’t mind the ‘Employee’ as it’s only a utility class. 12345678910111213interface IDepartment &#123; List&lt;Employee&gt; staff(); boolean contains(Employee e); void printStaff();&#125;class Employee &#123; String name; int rank; Employee(String name, int rank) &#123; this.name = name; this.rank = rank; &#125;&#125; Now that we have our core ‘Leaf’ interface, let’s create the concerete implementation as well as its composite implementation. 12345678910111213141516171819202122232425262728293031323334class Department implements IDepartment &#123; List&lt;Employee&gt; employees; Department(Employee... employees) &#123;this.employees = Arrays.asList(employees);&#125; List&lt;Employee&gt; staff() &#123; return employees; &#125; boolean contains(Employee e) &#123; return employees.contains(e); &#125; void printStaff() &#123; employees.sort((e1, e2) -&gt; e1.rank - e2.rank); for(Employee e : employees) System.out.println(e.name); &#125;&#125;class Division implements IDepartment &#123; List&lt;IDepartment&gt; departments; void addDepartment(IDepartment d) &#123; departments.add(d); &#125; void removeDepartment(IDepartment d) &#123; departments.remove(d); &#125; List&lt;Employee&gt; staff() &#123; List&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); for (IDepartment d : departments) staff.addAll(d.staff()); return staff; &#125; boolean contains(Employee e) &#123; for(IDepartment d : departments) if (d.contains(e)) return true; return false; &#125; void printStaff() &#123; for(IDepartment d : departments) d.printStaff(); &#125;&#125; Employees are extracted into a database class to increase the focus on ‘Client’ 123456789101112131415161718192021222324252627282930313233343536class DB &#123; static Employee james = new Employee(\"james\", 1); static Employee jack = new Employee(\"jack\", 2); static Employee john = new Employee(\"john\", 3); static Employee abraham = new Employee(\"abraham\", 5); static Employee abigale = new Employee(\"abigale\", 6); static Employee anna = new Employee(\"anna\", 5); static Employee brian = new Employee(\"brian\", 5); static Employee bernard = new Employee(\"bernard\", 6); static Employee bianca = new Employee(\"bianca\", 7); static Employee unknown = new Employee(\"Unknown\", 10);&#125;class Client &#123; Client() &#123; IDepartment marketing = new Department(DB.abigale, DB.abraham, DB.anna); IDepartment accounting = new Department(DB.bernard, DB.bianca, DB.brian); IDepartment management = new Department(DB.jack, DB.james, DB.john); Division finance = new Division(); finance.addDepartment(marketing); finance.addDepartment(accounting); Division westCoast = new Division(); westCoast.addDepartment(management); westCoast.addDepartment(finance); boolean exists = marketing.contains(DB.abigale); exists = westCoast.contains(DB.unknown); management.printStaff(); westCoast.printStaff(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}]},{"title":"Iterator Pattern","slug":"2012/iterator","date":"2012-03-02T17:10:56.000Z","updated":"2016-09-18T15:04:57.000Z","comments":true,"path":"2012/iterator/","link":"","permalink":"http://truelogician.com/2012/iterator/","excerpt":"Design Patterns Overview DefinitionGet the Iterator for Any Type of Collections in Subclasses. Provides a Way to Traverse a Collection of Objects Without Exposing Its Implementation.","text":"Design Patterns Overview DefinitionGet the Iterator for Any Type of Collections in Subclasses. Provides a Way to Traverse a Collection of Objects Without Exposing Its Implementation. Recipe The interface that defines the getIterator() method 123interface IIterable &#123; Iterator getIterator();&#125; Concrete implementations provide the iterator of a collection they might own. 1234567891011class ProductA implements IIterable &#123; Iterator getIterator() &#123; // return the iterator of a desired collection; &#125;&#125;class ProductB implements IIterable &#123; Iterator getIterator() &#123; // return the iterator of a desired collection; &#125;&#125; ServeHaving implemented the IIterable, it is now possible to iterate over the collections in each implementation. 12345678910class Client &#123; Client() &#123; ProductA product = new ProductA(); Iterator&lt;Integer&gt; iterator = product.getIterator(); while (iterator.hasNext()) &#123; Integer next = iterator.next(); /*implementations*/ &#125; &#125;&#125; Important Benefits It provides a uniform way to cycle through different types of collections. You can refer to each collection of objects in the same way. It avoids code duplication which might occur during the iteration over each of them. Example123interface IIterable &#123; Iterator getIterator();&#125; Suppose there are some implementations which somehow hold a form of a collection (i.e arrays, lists, hash-tables, etc). this pattern provides a way to get an iterator over those collections. 123456789101112131415161718192021222324class Inventory implements IIterable &#123; Collection&lt;String&gt; items = new ArrayList&lt;String&gt;(); Iterator getIterator() &#123; return items.iterator(); &#125;&#125;interface IUser &#123;&#125;interface ISession &#123;&#125;class OnlineUsers implements IIterable &#123; AbstractMap&lt;IUser, ISession&gt; users = new HashMap&lt;IUser, ISession&gt;(); Iterator getIterator() &#123; return users.keySet().iterator(); &#125;&#125;interface IPoint &#123;&#125;class Diagram implements IIterable &#123; IPoint[] points = new IPoint[10]; Iterator getIterator() &#123; return Arrays.asList(points).iterator(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Template Method Pattern","slug":"2012/template","date":"2012-02-16T20:47:19.000Z","updated":"2016-09-18T15:14:26.000Z","comments":true,"path":"2012/template/","link":"","permalink":"http://truelogician.com/2012/template/","excerpt":"Design Patterns Overview DefinitionCreate a Fixed Procedure and Vary its details for the Subclasses. Subclasses Decide How to implement Steps in an Algorithm.","text":"Design Patterns Overview DefinitionCreate a Fixed Procedure and Vary its details for the Subclasses. Subclasses Decide How to implement Steps in an Algorithm. Recipe The abstract product with basic behavior implementation as well as abstract methods (also called hooks). The hooks are to be implemented later on by the flavors of the product. 123456789101112131415161718192021abstract class Product &#123; void operationA() &#123; action1(); action3(); if (condition()) action4(); &#125; void operationB() &#123; action2(); action3(); action5(); &#125; abstract void action1(); void action2() &#123;/* implementation */&#125; abstract void action3(); void action4() &#123;/* implementation */&#125; abstract void action5(); abstract boolean condition();&#125; The product flavors with custom implementations. Note that how they can also override non-abstract methods (‘Product2’). 123456789101112131415161718192021class Product1 extends Product &#123; void action1() &#123;/*implementation*/&#125; void action3() &#123;/*implementation*/&#125; void action5() &#123;/*implementation*/&#125; boolean condition() &#123; /* return evaluation*/ &#125;&#125;class Product2 extends Product &#123; void operationA() &#123; action1(); action4(); &#125; void action1() &#123;/*implementation*/&#125; void action3() &#123;/*implementation*/&#125; void action5() &#123;/*implementation*/&#125; boolean condition() &#123; /* return evaluation*/ &#125;&#125; ServeThe required product can then be created and asked for its specific behavior. 12345678class Client &#123; Client() &#123; Product product = new Product1(); product.operationB(); product = new Product2(); product.operationA(); &#125;&#125; Important BenefitsCreates a group of subclasses that have to execute a similar group of methods but every step of these executions can be customized. ExampleSuppose that you’re assigned to create simple framework for parsing the messages used in the system. These messages have the common parts of header and payload. So, in order to parse a message, we should parse the header and in case of valid header, we can move on to parsing the payload. Accordingly, we know about the procedure of parsing a message, but the details are different based on each message. So let’s define the procedure first. 123456789101112131415abstract class Message &#123; String content; String header; String payload; Message(String content) &#123; this.content = content; &#125; void parse() &#123; header = parseHeader(); if (isValidHeader()) payload = parsePayload(); &#125; abstract String parseHeader(); abstract boolean isValidHeader(); abstract String parsePayload();&#125; Now for each existing message we can fine-tune the implementation details. 12345678910111213141516171819202122232425class HttpMessage extends Message &#123; HttpMessage(String content) &#123; super(content); &#125; String parseHeader() &#123; return \"parse header according to HTTP standards\"; &#125; boolean isValidHeader() &#123; return \"check validity based on valid HTTP headers\"; &#125; String parsePayload() &#123; return \"parse message payload based on HTTP body\"; &#125;&#125;class CustomMessage extends Message &#123; CustomMessage(String content) &#123; super(content); &#125; String parseHeader() &#123; return \"the header has 4 parts, each is 2 bytes\"; &#125; boolean isValidHeader() &#123; return \"valid if header ID equal to 300 or 400\"; &#125; String parsePayload() &#123; return \"from byte 10 and onward\"; &#125;&#125; The client invokes the base abstract method and the implementations are executed accordingly. 12345678class Client &#123; Client() &#123; Message message = new HttpMessage(\"&lt;valid HTTP message&gt;\"); message.parse(); message = new CustomMessage(\"&lt;valid Custom message&gt;\"); message.parse(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Bridge Pattern","slug":"2012/bridge","date":"2012-01-29T22:20:38.000Z","updated":"2016-09-18T14:55:34.000Z","comments":true,"path":"2012/bridge/","link":"","permalink":"http://truelogician.com/2012/bridge/","excerpt":"Design Patterns Overview DefinitionDecouple Products from Their Usage So That They can Change Independently. Make It Easier to Add More Capabilities to a Set of Subclasses Through Abstraction Layer.","text":"Design Patterns Overview DefinitionDecouple Products from Their Usage So That They can Change Independently. Make It Easier to Add More Capabilities to a Set of Subclasses Through Abstraction Layer. Recipe The family of products that is also very likely that in the future they will change and grow. 1234567891011121314interface IProduct &#123; void operation1(); void operation2();&#125;class ProductA implements IProduct &#123; void operation1() &#123;&#125; void operation2() &#123;&#125;&#125;class ProductB implements IProduct &#123; void operation1() &#123; &#125; void operation2() &#123; &#125;&#125; The bridge interface/abstract class. Consider how a product instance is received through constructor. 123456789101112131415161718192021abstract class AbstractBridge &#123; IProduct product; AbstractBridge(IProduct product) &#123; this.product = product; &#125; abstract void function1(); abstract void function2();&#125;class Bridge extends AbstractBridge &#123; IProduct product; Bridge(IProduct product) &#123; super(product); &#125; void function1() &#123; this.product.operation1(); &#125; void function2() &#123; this.product.operation2(); &#125;&#125; ServeNow that products family and the bridge exist, create bridges of desired products and use behaviors provided in a bridge. 12345678class Client &#123; Client() &#123; Bridge bridge1 = new Bridge(new ProductA()); bridge1.function2(); Bridge bridge2 = new Bridge(new ProductB()); bridge2.function1(); &#125;&#125; DiscussionYou might have already noticed the similarity between bridge and the adapter pattern. So What’s the Difference? The difference lies in when the pattern is about to be applied. The adapter create adaptability between an already existing ‘Product’ and ‘Adaptee’ over which one might not have any control (say a third-party library, or legacy code). The bridge pattern however, creates such adaptability up front; prior to classes being created or designed. In above implementation, developers might come up with more ‘IProduct’ implementations or more subclasses of ‘ProductA’ and ‘ProductB’ while rest assured that eventually methods will hook properly. Important Benefits Progressively adding functionality while separating out major differences using abstract classes. Helps when both abstractions and concrete classes are to be changed frequently and independently. ExampleImagine we’re designing graphics API to render form-components (Buttons, TextBoxes, Comboboxes and etc) on graphics containers such as web pages or application canvas. For now, let’s say that: We need to present Buttons, TextBoxes and ComboBoxes to render on webpage or canvas. They come in either light or dark themes. It’s not known how many components or themes are to be added in future. As a result, normally we might end up with classes below; while each has its own ‘render()’ implementation: Button ButtonDark ButtonLight TextBox TextBoxLight TextBoxDark ComboBox ComboBoxDark ComboBoxLight This approach, however has a drawback. What if we need to add a Checkbox? then we need to define the checkbox top class with two additional dark and light flavor. What if we need to add one more theme? then we need to add three more classes for each component. Not Very Optimal… Right?Applying the bridge pattern, let’s decouple the concept of ‘Theme’ from ‘GUI-Container’. 12345678910111213interface ITheme &#123; Object[] elements();&#125;class DarkTheme implements ITheme &#123; Object[] elements() &#123; // return dark graphics &#125;&#125;class LightTheme implements ITheme &#123; Object[] elements() &#123; // return light graphics &#125;&#125; Accordingly, the graphics containers will look like this: 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class GuiContainer &#123; ITheme theme; GuiContainer(ITheme theme) &#123; this.theme = theme; &#125; abstract void drawComboBox(); abstract void drawButton(); abstract void drawTextBox();&#125;class Website extends GuiContainer &#123; ITheme theme; Website(ITheme theme) &#123; super(theme); &#125; void drawComboBox() &#123; Object[] elements = theme.elements(); // get combobox graphics &amp; render on a webpage &#125; void drawButton() &#123; Object[] elements = theme.elements(); // get button graphics &amp; render on a webpage &#125; void drawTextBox() &#123; Object[] elements = theme.elements(); // get textbox graphics &amp; render on a webpage &#125;&#125;class Application extends GuiContainer &#123; ITheme theme; Application(ITheme theme) &#123; super(theme); &#125; void drawComboBox() &#123; Object[] elements = theme.elements(); // get combobox graphics &amp; render on a canvas &#125; void drawButton() &#123; Object[] elements = theme.elements(); // get button graphics &amp; render on a canvas &#125; void drawTextBox() &#123; Object[] elements = theme.elements(); // get textbox graphics &amp; render on a canvas &#125;&#125; Notice: ‘Theme’ and ‘GuiContainer’ are completely independent entities. Also, each GUI container only needs one theme at the same time and not more. 123456789class Client &#123; Client() &#123; ITheme darkTheme = new DarkTheme(); Website website = new Website(darkTheme); website.drawButton(); website.drawComboBox(); website.drawTextBox(); &#125;&#125; Alright, let’s answer the same questions now. What if we need to add a Checkbox? then we need to implement the logic for how to render it on both webpage and canvas. What if we need to add one more theme? then we need to return elements of that theme. Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}]},{"title":"Facade Pattern","slug":"2011/facade","date":"2011-12-14T19:43:13.000Z","updated":"2016-09-18T15:27:15.000Z","comments":true,"path":"2011/facade/","link":"","permalink":"http://truelogician.com/2011/facade/","excerpt":"Design Patterns Overview DefinitionCreate a Simplified Interface to a Set of Classes. Create a Cohesive Class Is Easier to Read, Test, Understand and Use by Grouping Methods with Common Tasks from a Set of Other Classes.","text":"Design Patterns Overview DefinitionCreate a Simplified Interface to a Set of Classes. Create a Cohesive Class Is Easier to Read, Test, Understand and Use by Grouping Methods with Common Tasks from a Set of Other Classes. Recipe A set of products with different behaviors. 1234567891011121314151617interface IProductA &#123; void operationA1(); void operationA2(); void operationA3();&#125;interface IProductB &#123; void operationB1(); void operationB2(); void operationB3();&#125;interface IProductC &#123; void operationC1(); void operationC2(); void operationC3();&#125; The facade class that groups methods with common tasks for a certain purpose. 123456789class Facade &#123; IProductA productA; IProductB productB; IProductC productC; void operationA1() &#123; productA.operationA1(); &#125; void operationB2() &#123; productB.operationB2(); &#125; void operationC3() &#123; productC.operationC3(); &#125;&#125; ServeSince only the facade is exposed, the client cannot access any extra unnecessary methods from products. 1234567class Client &#123; Client() &#123; Facade facade = new Facade(); facade.operationA1(); facade.operationC3(); &#125;&#125; Important Benefits Hides the complexity and the unnecessary code from the client. ExampleSuppose an internet shopping company is trying to create a web service for their products. They already have an accounting and posting department as well as an inventory.The web service does not need to know any details of each department’s code or expose them to the end user. 1234567891011121314151617interface IInventory &#123; void transportToDispatch(String itemId); void addItem(String itemId, int amount); void removeItem(String itemId, int amount);&#125;interface IAccounting &#123; void deleteReceipt(String receiptId); void registerOrder(String itemId); double GetAnnualSale();&#125;interface IPostalService &#123; void dispatch(String itemId, String userId); void track(String dispatchId); void cancel(String dispatchId);&#125; The facade will expose an useful method for the end user and consumes the related methods. 12345678910111213class OrderFacade &#123; IAccounting accounting; IInventory inventory; IPostalService postalService; void order(String order) &#123; String itemId = \"/*extract item id from order*/\"; accounting.registerOrder(itemId); inventory.transportToDispatch(itemId); String userId = \"/*extract user id from order*/\"; postalService.dispatch(itemId, userId); &#125;&#125; As a result, the end user can now only access the required methods. 12345678910class WebService &#123; void createOrder(String orderProperties) &#123; OrderFacade facade = new OrderFacade(); facade.order(orderProperties); &#125; void addToWishlist(String itemId) &#123; /*implementation*/ &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}]},{"title":"Adapter Pattern","slug":"2011/adapter","date":"2011-11-28T21:12:55.000Z","updated":"2016-09-18T15:20:14.000Z","comments":true,"path":"2011/adapter/","link":"","permalink":"http://truelogician.com/2011/adapter/","excerpt":"Design Patterns Overview DefinitionCreate Adaptability Among Different Interfaces. Adapt an Existing Class to Work With Others Without Modifying It.","text":"Design Patterns Overview DefinitionCreate Adaptability Among Different Interfaces. Adapt an Existing Class to Work With Others Without Modifying It. Recipe The product definition. 123interface IProduct &#123; void operation();&#125; A different class that needs to be used like an IProduct. 1234class Adaptee &#123; void procedureA() &#123;/* implementation */&#125; void procedureB() &#123;/* implementation */&#125;&#125; The adapter which on one hand implements the IProduct and on the other hand has the adaptee. Note that Adapter selects the correct corresponding method from the adaptee. 123456class Adapter implements IProduct &#123; Adaptee adaptee; Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; // imagine that operation shall be mapped to procedureB void operation() &#123; adaptee.procedureB(); &#125;&#125; ServeCreate an adapter and pass an instance of the class that needs to be adapted. It will behave as if it is a product. 123456class Client &#123; Client() &#123; Adapter adapter = new Adapter(new Adaptee()); adapter.operation(); &#125;&#125; Important Benefits Allows you to translate the behaviors in one family of classes to not-completely-different behaviors in another family of classes. ExampleSuppose that you’ve been assigned to update the code behind the user profile of a legacy code in a social networking company. The legacy code will be running in some regions of the world, however the company wants to update user profiles in some small regions. The new code for the profile looks very simple. Two methods to update and also sign out the owner of it. 1234interface IModernProfile &#123; void update(Object[] props); void signOut();&#125; The legacy profile, like it or not, has much more granular methods and behaviors. 12345678class LegacyProfile &#123; void closeCurrentSession() &#123;/* implementation */&#125; void closeDatabaseConnections() &#123;/* implementation */&#125; void setUsername(String username) &#123;/* implementation */&#125; void setFullName(String fullName) &#123;/* implementation */&#125; void setUserAge(int age) &#123;/* implementation */&#125; void setUserAddress(String address) &#123;/* implementation */&#125;&#125; Since we cannot change its source code directly, we can write an adapter that implements the new profile interface and accepts an instance of the old one. Notice that the adapter will map actions between the adapter and the adaptee. 12345678910111213141516class ModernProfileAdapter implements IModernProfile &#123; LegacyProfile legacyProfile; ModernProfileAdapter(LegacyProfile legacyProfile) &#123; this.legacyProfile = legacyProfile; &#125; void update(Object[] props) &#123; legacyProfile.setUsername(props[0].toString()); legacyProfile.setFullName(props[1].toString()); legacyProfile.setUserAge(toInt(props[2])); legacyProfile.setUserAddress(props[3].toString()); &#125; void signOut() &#123; legacyProfile.closeDatabaseConnections(); legacyProfile.closeCurrentSession(); &#125;&#125; Finally, we’re now able to use the legacy profile as if it’s a modern profile. 123456789101112class Client &#123; Client() &#123; ModernProfileAdapter profileAdapter = new ModernProfileAdapter(new LegacyProfile()); profileAdapter.update (new Object[] &#123; \"john12\", \"John Doe\", 33, \"1234 XYZ Street\" &#125;); profileAdapter.signOut(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}]},{"title":"Decorator Pattern","slug":"2011/decorator","date":"2011-09-24T09:27:03.000Z","updated":"2016-09-18T15:25:54.000Z","comments":true,"path":"2011/decorator/","link":"","permalink":"http://truelogician.com/2011/decorator/","excerpt":"Design Patterns Overview DefinitionProvide New Abilities/Behaviors at Runtime. Wrapping an Object (Through Composition) In Order to Provide Additional Abilities","text":"Design Patterns Overview DefinitionProvide New Abilities/Behaviors at Runtime. Wrapping an Object (Through Composition) In Order to Provide Additional Abilities Recipe The product definition and one concrete class to show the pattern use later on. 123456789interface IProduct &#123; void operation1(); void operation2();&#125;class Product implements IProduct &#123; void operation1() &#123;/*implementation*/&#125; void operation2() &#123;/*implementation*/&#125;&#125; The definition of a ‘Decorator’ along various derivations; each of them modifies the given product’s behaviors and abilities in a certain way. 1234567891011121314151617class Decorator implements IProduct &#123; IProduct product; Decorator(IProduct product) &#123; this.product = product; &#125; void operation1() &#123; product.operation1(); &#125; void operation2() &#123; product.operation2(); &#125;&#125;class DecoratorX extends Decorator &#123; DecoratorX(IProduct product) &#123; super(product); &#125; void operation1() &#123;/*modified implementation*/&#125; void operation2() &#123;/*modified implementation*/&#125;&#125;class DecoratorY extends Decorator &#123; DecoratorY(IProduct product) &#123; super(product); &#125; void operation1() &#123;/*modified implementation*/&#125; void operation2() &#123;/*modified implementation*/&#125;&#125; ServeOnce decorators are in place, create an instance of the base product and then wrap them with the new decorators. It is basically like an onion with the base product at the core which is wrapped by layers of decorators around one another. 12345678class Client &#123; Client() &#123; IProduct customProduct = new DecoratorX(new DecoratorY(new Product())); customProduct.operation1(); customProduct.operation2(); &#125;&#125; Important Benefits It simplifies the code while it is more flexible than inheritance and above all it gives us the ability to extend the old code with the new code instead of rewriting it. It allows the behavior to be extended without the need to modify the existing code. You can wrap a component with any number of decorators. ExampleSuppose that we are about to create a logger that logs text messages to file. So, the basic logger only appends given strings to a file. However, many of our developer users also demanded us to equip the logs with the current timestamp. Our test department users also requested the logs to be colorful, since they open the logs with an enhanced text editor and they want errors and warning to stand out. Accordingly, the product would be a ‘Logger’ as defined below. 123456interface ILogger &#123; void log(String message);&#125;class Logger implements ILogger &#123; void log(String message) &#123;/* log to file */&#125;&#125; Based on the demands, instead of modifying the base logger, we could introduce two decorators to improve the base logger. 1234567891011121314151617181920212223242526272829class Decorator implements ILogger &#123; ILogger logger; Decorator(ILogger logger) &#123; this.logger = logger; &#125; void log(String message) &#123; logger.log(message); &#125;&#125;class TimeDecorator extends Decorator &#123; TimeDecorator(ILogger logger) &#123; super(logger); &#125; void log(String message) &#123; String timestamp = \"&lt;formatted-timestamp-of-current-moment&gt;\"; String timestampedMessage = String.format(\"Timestamp %s: %s\", timestamp, message); super.log(timestampedMessage); &#125;&#125;class ColorDecorator extends Decorator &#123; ColorDecorator(ILogger logger) &#123; super(logger); &#125; void log(String message) &#123; super.log(toColored(message)); &#125; void toColored(String message) &#123; String template = \"&lt;font color=\\\"%s\\\"&gt;%s&lt;/font&gt;\"; if (message.startsWith(\"Error\")) return String.format(template, \"red\", message); if (message.startsWith(\"Warning\")) return String.format(template, \"yellow\", message); return String.format(template, \"green\" message); &#125;&#125; Now, the client is able to equip the base logger with any amount of decorators and use it. 123456789101112class Client &#123; Client() &#123; Logger simpleLogger = new Logger(); ColorDecorator colorLogger = new ColorDecorator(simpleLogger); ILogger timedColorLogger = new TimeDecorator(colorLogger); timedColorLogger.log(\"Error: invalid id\"); timedColorLogger.log(\"Warning: address not defined\"); simpleLogger.log(\"application started\"); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Structural","slug":"Software-Architecture/Design-Patterns/Types/Structural","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Structural/"}]},{"title":"Command Pattern","slug":"2011/command","date":"2011-07-16T08:14:47.000Z","updated":"2017-01-09T08:13:29.000Z","comments":true,"path":"2011/command/","link":"","permalink":"http://truelogician.com/2011/command/","excerpt":"Design Patterns Overview DefinitionCreate a Set of Reusable Commands For Various Products. Encapsulate the concept of an action (Command).","text":"Design Patterns Overview DefinitionCreate a Set of Reusable Commands For Various Products. Encapsulate the concept of an action (Command). Recipe The definition of product and its operations. The product subclasses family. 1234567891011121314151617181920interface IProduct &#123; void doA(); void doB(); void doC();&#125;class Product1 implements IProduct &#123; void doA() &#123;/*implementation*/&#125; void doB() &#123;/*implementation*/&#125; void doC() &#123;/*implementation*/&#125;&#125;class Product2 implements IProduct &#123; void doA() &#123;/*implementation*/&#125; void doB() &#123;/*implementation*/&#125; void doC() &#123;/*implementation*/&#125;&#125;class Product3 implements IProduct &#123; void doA() &#123;/*implementation*/&#125; void doB() &#123;/*implementation*/&#125; void doC() &#123;/*implementation*/&#125;&#125; The command has a very simple structure. a command can only be executed. The command subclasses accept such a product and invoke corresponding actions on them. 12345678910111213interface ICommand &#123; void execute();&#125;class CommandX implements ICommand &#123; IProduct product; CommandX(IProduct product) &#123; this.product = product; &#125; void execute() &#123; product.doC(); &#125;&#125;class CommandY implements ICommand &#123; IProduct product; CommandY(IProduct product) &#123; this.product = product; &#125; void execute() &#123; product.doA(); &#125;&#125; ServeNow that we defined both the command and product, we can simple pass a product to a command and ask it to execute. 1234567class Client &#123; Client() &#123; new CommandY(new Product2()).execute(); new CommandX(new Product1()).execute(); new CommandX(new Product2()).execute(); &#125;&#125; Important Benefits Allows using a set of commands over and over on different products. ExampleLet’s imagine that we’re about to develop a visual GUI designing framework. Also we are about to provide a functionality that allows developers to select a component on the screen and hit the enable/disable button to act on the component accordingly. We also know that enable or disable functionality workd differently on different GUI components. As a result let’s define our components first 12345678910111213141516171819202122232425262728293031323334353637interface IComponent &#123; void add(IComponent component); void enable(); void disable();&#125;class TextBox implements IComponent &#123; TextBox(String text) &#123;/* set text */&#125; void add(IComponent component) &#123;/* no sub component */&#125; void enable() &#123;/* enable text component */&#125; void disable() &#123;/* disable text component */&#125;&#125;class ListBox implements IComponent &#123; void add(IComponent component) &#123; /* add to list as a TextBox */ &#125; void enable() &#123; /* go through all child text components and enable them */ &#125; void disable() &#123; /* go through all child text components and disable them */ &#125;&#125;class Panel implements IComponent &#123; void add(IComponent component) &#123; /* add to the container */ &#125; void enable() &#123; /* go through all child components and enable them */ &#125; void disable() &#123; /* go through all child components and disable them */ &#125;&#125; Note the command interface also provides the ability to undo 12345678910111213141516interface ICommand &#123; void execute(); void undo();&#125;class Enable implements ICommand &#123; IComponent component; Enable(IComponent component) &#123; this.component = component; &#125; void execute() &#123; component.enable(); &#125; void undo() &#123; component.disable(); &#125;&#125;class Disable implements ICommand &#123; IComponent component; Disable(IComponent component) &#123; this.component = component; &#125; void execute() &#123; component.disable(); &#125; void undo() &#123; component.enable(); &#125;&#125; And finnaly the client that allows for enabling/disabling one component or a group of them. 12345678910111213141516171819202122class Client &#123; Client() &#123; IComponent orange = new TextBox(\"Orange\"); IComponent apple = new TextBox(\"Apple\"); IComponent banana = new TextBox(\"Banana\"); IComponent fruitsList = new ListBox(); fruitsList.add(orange); fruitsList.add(apple); fruitsList.add(banana); IComponent panel = new Panel(); panel.add(fruitsList); ICommand disablePanel = new Disable(panel); ICommand disableList = new Disable(fruitsList); disablePanel.execute(); disablePanel.undo(); disableList.execute(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Prototype Pattern","slug":"2011/prototype","date":"2011-06-09T17:11:09.000Z","updated":"2016-09-18T15:28:34.000Z","comments":true,"path":"2011/prototype/","link":"","permalink":"http://truelogician.com/2011/prototype/","excerpt":"Design Patterns Overview DefinitionCreate new instances by copying the existing one. Client code can make new instances without knowing which specific class is being instantiated.","text":"Design Patterns Overview DefinitionCreate new instances by copying the existing one. Client code can make new instances without knowing which specific class is being instantiated. Recipe The product prototype and its concrete implementation. Notice how each product casts the clone to self type. 123456789101112131415161718192021interface IPrototype extends Cloneable &#123; IPrototype copy();&#125;class ProductA implements IPrototype &#123; IPrototype copy() &#123; ProductA product = null; try &#123; product = (ProductA) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; log(e); &#125; return product; &#125;&#125;class ProductB implements IPrototype &#123; IPrototype copy() &#123; ProductB product = null; try &#123; product = (ProductB) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; log(e); &#125; return product; &#125;&#125; The clone factory which receives a prototype or a subclass of it and creates a clone of it 12345class CloneFactory &#123; IPrototype clone(IPrototype prototype) &#123; return prototype.copy(); &#125;&#125; ServeNow that you have everything in place, to clone a product, simply pass it to the clone factory and cast it back. 12345678910class Client &#123; ProductA a = new ProductA(); ProductB b = new ProductB(); Client() &#123; CloneFactory cloneFactory = new CloneFactory(); ProductA a1 = (ProductA) cloneFactory.clone(a); ProductA a2 = (ProductA) cloneFactory.clone(a); ProductB b1 = (ProductB) cloneFactory.clone(b); &#125;&#125; Important Benefits Reduces the need for creating subclasses. ExampleAlright, imagine that a graphical application needs to present its graphical elements. In this example, they are ‘Pixel’ and ‘Circle’. A Pixel is defined by its x and y coordinates and a circle is defined by its center and radius. We want provide our users with shape duplication ability in order to clone shapes instead of drawing an identical ones. 123456789101112131415161718192021222324252627282930313233343536interface IPrototype extends Cloneable &#123; IPrototype copy();&#125;class Pixel implements IPrototype &#123; int x; int y; Pixel(int x, int y) &#123; this.x = x; this.y = y; &#125; IPrototype copy() &#123; Pixel pixel = null; try &#123; pixel = (Pixel) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; log(e); &#125; return pixel; &#125;&#125;class Circle implements IPrototype &#123; Pixel center; double radius; Circle(Pixel center, double radius) &#123; this.center = center; this.radius = radius; &#125; IPrototype copy() &#123; Circle circle = null; try &#123; circle = (Circle) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; log(e); &#125; return circle; &#125; void draw() &#123;/*logic to draw a circle*/&#125;&#125; The clone factory is completely untouched. 12345class CloneFactory &#123; IPrototype clone(IPrototype prototype) &#123; return prototype.copy(); &#125;&#125; And finally the ‘Canvas’ provides the duplication functionality and draws a circle with the same specs next to the original one. 12345678class Canvas &#123; void duplicate(Circle circle) &#123; CloneFactory cloneFactory = new CloneFactory(); Circle clone = (Circle) cloneFactory.clone(circle); clone.center = new Pixel(clone.center.x + 1, clone.center.y + 1); clone.draw(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}]},{"title":"Null Object Pattern","slug":"2011/null","date":"2011-04-12T15:57:12.000Z","updated":"2016-10-03T22:27:07.000Z","comments":true,"path":"2011/null/","link":"","permalink":"http://truelogician.com/2011/null/","excerpt":"Design Patterns Overview Although Null Object pattern is not part of the classical design patterns, but it is certainly one of those useful mindsets every developer shall practice over and over. DefinitionSubstitute Null References with Neutral Objects That Cause No Side Effects.","text":"Design Patterns Overview Although Null Object pattern is not part of the classical design patterns, but it is certainly one of those useful mindsets every developer shall practice over and over. DefinitionSubstitute Null References with Neutral Objects That Cause No Side Effects. A Null Object is an object with no referenced value or with defined neutral (“null”) behavior. (Wikipedia) Recipe Definition of the ‘Nullable’ interface. The purpose of ‘isNull()’ method is to identify Null-Objects. 123interface Nullable &#123; boolean isNull();&#125; The ‘Product’ interface, its concrete implementation as well as the null implementation. 1234567891011121314151617interface IProduct extends Nullable &#123; /* definition of states &amp; behaviors */&#125;class Product implements IProduct &#123; /* normal implementation of states &amp; behaviors */ boolean isNull() &#123; return false; &#125;&#125;class NullProduct implements IProduct &#123; /* neutral implementation of states and behaviors */ boolean isNull() &#123; return true; &#125;&#125; Important Benefits Removes all the null checks (usually a substantial amount of code). Increases code readability. Carves out the business logic. Eliminates null pointer/reference exceptions from being thrown. Encourages considering conditions when there is absence of an object. The downside of this pattern happens when we’re kind of forced to introduce Null-Objects for almost all available types (esp. within the object dependency hierarchy). This will cause a huge increase in the amount of interfaces and null-class definitions. ExampleImagine a service that processes purchase orders. The service will go through ordered items one by one and puts them on the shipping list if user has enough credits to buy them. Following uses merely Null Objects instead of any real data. Notice how uniformly a normal-order, a null-order or null-items within an order are processed. Look how the business logic seems pure, readable and free of clatter code an unnecessary checks. 123456789101112131415161718192021222324252627282930313233class Client &#123; Client() &#123; IOrder orderA = new NullOrder(); IOrder orderB = new Order(\"invalid-user-id\"); orderB.add(new NullItem()); orderB.add(new NullItem()); orderB.add(new NullItem()); process(orderA); process(orderB); &#125; void process(IOrder order) &#123; IUser user = search(order.userId()); for(IItem item : order.items()) purchase(item, user); &#125; void purchase(IItem item, IUser user) &#123; if (user.credits() &lt; item.value()) return; user.setCredits(user.credits() - item.value()); ship(item, item.amount(), user); &#125; private IUser search(String userId) &#123; return new NullUser(); &#125; private void ship(IItem item, int amount, IUser user) &#123; String log = item.title() + \"-&gt;\" + user.address(); System.out.println(log); &#125;&#125; For the above client to work, we need the definition of the ‘Nullable’. 123interface Nullable &#123; boolean isNull();&#125; A ‘User’ is an entity that can order one/several items. 1234567891011121314151617181920interface IUser extends Nullable &#123; String address(); int credits(); void setCredits(int credits);&#125;class User implements IUser &#123; int credits; String address; boolean isNull() &#123; return false; &#125; String address() &#123; return address; &#125; int credits() &#123; return credits; &#125; void setCredits(int c) &#123; credits = c; &#125;&#125;class NullUser implements IUser &#123; boolean isNull() &#123; return true; &#125; String address() &#123; return \"\"; &#125; int credits() &#123; return 0; &#125; void setCredits(int credits) &#123; &#125;&#125; An ‘Item’ represents an inventory item with certain properties. Notice it shall not be possible to create an ‘Item’ with empty ‘id’, since it’s defined in NullItem. 123456789101112131415161718192021222324interface IItem extends Nullable &#123; String id(); String title(); int value(); int amount();&#125;class Item implements IItem &#123; String id; String title; int value; int amount; boolean isNull() &#123; return false; &#125; String id() &#123; return id; &#125; int value() &#123; return value; &#125; int amount() &#123; return amount; &#125; String title() &#123; return title; &#125;&#125;class NullItem implements IItem &#123; boolean isNull() &#123; return true; &#125; String id() &#123; return \"\"; &#125; int value() &#123; return 0; &#125; int amount() &#123; return 0; &#125; String title() &#123; return \"\"; &#125;&#125; An ‘Order’ defines which items are requested by which user. 123456789101112131415161718192021interface IOrder extends Nullable &#123; void add(IItem item); String userId(); List&lt;IItem&gt; items();&#125;class Order implements IOrder &#123; String userId; List&lt;IItem&gt; items = new ArrayList&lt;IItem&gt;(); Order(String userId) &#123; this.userId = userId; &#125; void add(IItem item) &#123; items.add(item); &#125; String userId() &#123; return userId; &#125; List&lt;IItem&gt; items() &#123; return items; &#125; boolean isNull() &#123; return false; &#125;&#125;class NullOrder implements IOrder &#123; void add(IItem item) &#123; &#125; String userId() &#123; return \"\"; &#125; List&lt;IItem&gt; items() &#123; return new ArrayList&lt;IItem&gt;(); &#125; boolean isNull() &#123; return true; &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Builder Pattern","slug":"2011/builder","date":"2011-03-19T21:37:18.000Z","updated":"2016-09-18T15:23:49.000Z","comments":true,"path":"2011/builder/","link":"","permalink":"http://truelogician.com/2011/builder/","excerpt":"Design Patterns Overview DefinitionSimplify Creation of Objects Which Need Many Properties for Creation.","text":"Design Patterns Overview DefinitionSimplify Creation of Objects Which Need Many Properties for Creation. Recipe The product definition along with its required/optional properties. Notice it uses the passed ‘builder’ object to propagate its property values. 1234567891011class Product &#123; String propertyA; int propertyB; boolean propertyC; Product(Builder builder) &#123; propertyA = builder.propertyA; propertyB = builder.propertyB; propertyC = builder.propertyC; &#125;&#125; The builder which almost maps the properties of the product. Notice the setter method return a ‘Builder’ to allow chaining methods. Enforce the product’s required properties in the builder too. 12345678910111213141516171819202122class Builder &#123; String propertyA; int propertyB; boolean propertyC; Builder setPropertyA(String value) &#123; propertyA = value; return this; &#125; Builder setPropertyB(int value) &#123; propertyB = value; return this; &#125; Builder setPropertyC(boolean value) &#123; propertyC = value; return this; &#125; Product build() &#123; return new Product(this); &#125;&#125; The build director which could be optional to have. It uses the ‘Builder’ to instantiate certain products. 12345678910111213141516class BuildDirector &#123; static Product buildAbc123True() &#123; return new Builder() .setPropertyA(\"abc\") .setPropertyB(123) .setPropertyC(true) .build(); &#125; static Product buildDef456False() &#123; return new Builder() .setPropertyA(\"def\") .setPropertyB(456) .setPropertyC(false) .build(); &#125;&#125; ServeIt is now possible to use the build director to create specific products or simply ask the builder to assign the product’s properties and build it. 123456789101112class Client &#123; Client() &#123; Product p1 = BuildDirector.buildAbc123True(); Product p2 = BuildDirector.buildDef456False(); Product p3 = new Builder() .setPropertyA(\"xyz\") .setPropertyB(789) .setPropertyC(true) .build(); &#125;&#125; Important BenefitsHiding from clients the creation of all side-objects and logics that are probably required for an instantiation. Hence, only the builder will know the specifics of this creation and no one else. ExampleKeeping in mind that the following code is merely an example, let’s imaging that we need to create our own Socket class. Well, one might come up with many properties when designing a sophisticated object such as this. Note that two of these properties however, are mandatory for instantiation and as a result are part of the socket builder constructor. 12345678910111213141516171819class Socket &#123; InetAddress addr; int port; boolean keepAlive; ComplexProperty complexProperty; long timeout; long sendBufferSize Socket(SocketBuilder builder) &#123; this.addr = builder.addr; this.port = builder.port; this.keepAlive = builder.keepAlive; this.complexProperty = builder.complexProperty; this.socketChannel = builder.socketChannel; this.timeout = builder.timeout; this.sendBufferSize = builder.sendBufferSize; &#125;&#125; The builder class. Note that how builder tries to hide the complexity of object creation within ‘setComplexProperty()’ method. 123456789101112131415161718192021222324252627282930313233343536373839class SocketBuilder &#123; InetAddress addr; int port; boolean keepAlive; boolean complexProperty; long timeout; long sendBufferSize SocketBuilder(InetAddress addr, int port) &#123; this.addr = addr; this.port = port; &#125; Builder setKeepAlive(boolean value) &#123; keepAlive = value; return this; &#125; Builder setComplexProperty(String simpleValue) &#123; /* performing complex actions on simpleValue to create the complexValue needed for the property */ complexProperty = complexValue; return this; &#125; Builder setTimeout(long value) &#123; timeout = value; return this; &#125; Builder setSendBufferSize(long value) &#123; sendBufferSize = value; return this; &#125; Product build() &#123; return new Socket(this); &#125;&#125; And finally the builder class which can either be used in a director or the client code. 12345678910111213class SocketDirector &#123; static InetAddress host = InetAddress.getByName(\"127.0.0.1\"); static Product buildHostSocket() &#123; return new SocketBuilder(host, 8080) .setKeepAlive(true) .setTimeout(0) .setSendBufferSize(1024) .setComplexProperty(\"F42\"); .build(); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}]},{"title":"Singleton Pattern","slug":"2011/singleton","date":"2011-02-21T08:49:21.000Z","updated":"2016-09-18T15:29:13.000Z","comments":true,"path":"2011/singleton/","link":"","permalink":"http://truelogician.com/2011/singleton/","excerpt":"Design Patterns Overview DefinitionMaking Only One Object of a Class to Be Available for All. Making Only One Object of a Class to Be Available for All.","text":"Design Patterns Overview DefinitionMaking Only One Object of a Class to Be Available for All. Making Only One Object of a Class to Be Available for All. RecipeThere are different ways to define a singleton. The snippet below presents one of the simplest thread-safe approaches that is not too complicated to confuse you and also not too simple to ignore the complexities it might require in real implementation. A class with a private constructor and a private instance of itself that can be assigned only once. 1234567891011121314151617class Singleton &#123; private static Singleton singleton; // constructor private Singleton() &#123; &#125; static Singleton getInstance() &#123; if (singleton != null) return singleton; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125; void operation() &#123;/*do sth.*/&#125;&#125; ServeAfter defining the singleton, all other classes can only access the very same instance of it across the virtual machine (JVM) as shown below. 123456class Client &#123; Client() &#123; Singleton singleton = Singleton.getInstance(); singleton.operation(); &#125;&#125; Important BenefitsDisadvantages of singletons are far more than their benefits. They reduce testability in great deal and introduce unnecessary coupling throughout the system. A singleton can yield best results in a situation where various parts of an application concurrently try to access a shared resource. An example of a shared resource would be Logger, Print Spooler, etc.In general, the use of singletons are only encouraged through the dependency injection. Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}]},{"title":"Abstract Factory Pattern","slug":"2010/abstract-factory","date":"2010-12-03T17:10:43.000Z","updated":"2016-09-18T14:54:59.000Z","comments":true,"path":"2010/abstract-factory/","link":"","permalink":"http://truelogician.com/2010/abstract-factory/","excerpt":"Design Patterns Overview DefinitionGroup Factories That Produce Similar Products. Choose a Factory at Runtime, in Order to Create Different Objects of a Certain Category.","text":"Design Patterns Overview DefinitionGroup Factories That Produce Similar Products. Choose a Factory at Runtime, in Order to Create Different Objects of a Certain Category. Recipe Definition of the products. In our case, 4 products: product Type A (comes in A1 &amp; A2 Flavors) product Type B (comes in B1 &amp; B2 Flavors) 123456789/* Product A Flavors */interface IProductA &#123; &#125;class ProductA1 implements IProductA &#123; &#125;class ProductA2 implements IProductA &#123; &#125;/* Product B Flavors */interface IProductB &#123; &#125;class ProductB1 implements IProductB &#123; &#125;class ProductB2 implements IProductB &#123; &#125; The family of factories. Notice that when ‘Factory2’ wants to create a product of type ‘A’, it returns ‘A1’ (and not ‘A2’) and this basically tries to emphasize that it is possible to build our factories in a way to return various flavors of available products according to the software needs. 12345678910111213interface IFactory &#123; IProductA createA(); IProductB createB();&#125;class Factory1 implements IFactory &#123; IProductA createA() &#123; return new ProductA1(); &#125; IProductB createB() &#123; return new ProductB1(); &#125;&#125;class Factory2 implements IFactory &#123; IProductA createA() &#123; return new ProductA1(); &#125; IProductB createB() &#123; return new ProductB2(); &#125;&#125; Now that we have the factories, let’s have simple static method that chooses a factory for us at runtime to create the right product. The ‘Props’ is an arbitrary object that contains some properties on which the selection is based. 12345678class FactorySelector &#123; static IFactory selectBy(Props props) &#123; if(/*shall select factory1?*/) return new Factory1(); if(/*shall select factory2?*/) return new Factory2(); &#125;&#125; ServeIf you have everything ready, then it would be only a matter of asking ‘FactorySelector’ to choose the right factory and create the desired product. 123456class Client &#123; Client() &#123; IFactory factory = FactorySelector.selectBy(props); IProductB product = factory.createB(); &#125;&#125; Important Benefits It basically has advantages similar to the factory pattern. ExampleLet’s say that we want to print some messages. The printer object can be designed to print messages to file, console, paper and etc. Messages can also come in different formats such as unstructured text, xml, json and etc. As a result, the product hierarchy is define as following. 12345678910111213141516171819interface IPrinter &#123; void print(String message);&#125;class ConsolePrinter implements IPrinter &#123; void print(String message) &#123;/*to console*/&#125;&#125;class FilePrinter implements IPrinter &#123; void print(String message) &#123;/*to file*/&#125;&#125;interface IParser &#123; String parse(String message);&#125;class JsonParser implements IParser &#123; String parse(String message) &#123; /*parse json*/ &#125;&#125;class XmlParser implements IParser &#123; String parse(String message) &#123; /*parse xml*/ &#125;&#125; Two different factories are defined here: ‘Logger’ which logs json messages to file ‘Display’ which shows xml messages in console 1234567891011121314151617181920212223interface IFactory &#123; IPrinter createPrinter(); IParser createParser(); void printMessage(String message);&#125;abstract class AbstractFactory implements IFactory &#123; void printMessage(String message) &#123; IPrinter printer = createPrinter(); IParser parser = createParser(); printer.print(parser.parse(message)); &#125;&#125;class Logger extends AbstractFactory &#123; IPrinter createPrinter() &#123; return new FilePrinter(); &#125; IParser createParser() &#123; return new JsonParser(); &#125;&#125;class Display extends AbstractFactory &#123; IPrinter createPrinter() &#123; return new ConsolePrinter(); &#125; IParser createParser() &#123; return new XmlParser(); &#125;&#125; Our ‘FactorySelector’ chooses the proper factory based on a given string. 12345678class FactorySelector &#123; static IFactory select(String type) &#123; if(type.equals(\"display\")) return new Display(); if(type.equals(\"logger\")) return new Logger(); &#125;&#125; And finally, the client code can use factories as demonstrated. 12345678910111213141516class Client &#123; IFactory factory; Client() &#123; factory = FactorySelector.select(\"logger\"); factory.printMessage(\"&#123; \\\"hello\\\" : \\\"world\\\" &#125;\"); writeOutput(\"writing to file...\"); factory = FactorySelector.select(\"display\"); writeOutput(\"writing to console\"); &#125; void writeOutput(String message) &#123; factory.createPrinter().print(message); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}]},{"title":"Factory Method Pattern","slug":"2010/factory","date":"2010-11-25T22:10:55.000Z","updated":"2016-09-18T14:52:42.000Z","comments":true,"path":"2010/factory/","link":"","permalink":"http://truelogician.com/2010/factory/","excerpt":"Design Patterns Overview DefinitionHaving Decisions of object creation to be made at Runtime. Create Objects Without Knowing the Specific Type.","text":"Design Patterns Overview DefinitionHaving Decisions of object creation to be made at Runtime. Create Objects Without Knowing the Specific Type. RecipesSimple Factory: Centralized Object Instantiation A hierarchy of products with a common parent. 1234interface IProduct &#123;&#125;class ProductA implements IProduct &#123;&#125;class ProductB implements IProduct &#123;&#125;class ProductC implements IProduct &#123;&#125; The Factory class to make the decision making. Decision is based on the properties presented by ‘Props’ object. The decision of which product to create is integrated in one place. 1234567class Factory &#123; IProduct createProduct(Props props) &#123; if (props ....) return new ProductA(); if (props ....) return new ProductB(); if (props ....) return new ProductC(); &#125;&#125; Factory Method: Decentralized Object Instantiation. Again, a hierarchy of products with a common parent. 1234interface IProduct &#123;&#125;class ProductA implements IProduct &#123;&#125;class ProductB implements IProduct &#123;&#125;class ProductC implements IProduct &#123;&#125; The product consumer with an abstract method. This will give the responsibility of product creation to subclasses 1234567abstract class Consumer &#123; void consume() &#123; IProduct p = createProduct(); /*logic for consuming the product*/ &#125; abstract IProduct createProduct();&#125; Consumer subclasses that each might need to consume a certain product. 123456789101112131415class ConsumerA extends Consumer &#123; IProduct createProduct() &#123; return new ProductA(); &#125;&#125;class ConsumerB extends Consumer &#123; IProduct createProduct() &#123; return new ProductB(); &#125;&#125;class ConsumerC extends Consumer &#123; IProduct createProduct() &#123; return new ProductC(); &#125;&#125; ServeUsing the simple factory is trivial since the client only needs to somehow pass a ‘Props’ object to the Factory and receive an instance of the product. For the 2nd approach, the snippet below, demonstrates how a consumer of certain type is created and that the creation of the product is pushed to the consumer itself. 123456class Client &#123; Client() &#123; Consumer consumerB = new ConsumerB(); consumerB.consume(); &#125;&#125; Important Benefits Getting rid of many scattered if-else statements used for object creation. Making it easier to modify the object creation logic. The client knows what types of classes are possible to build. ExampleSuppose that we want to send a message from one computer to another. This can be done in various ways such as sending via TCP, email, web services and etc. In such case, let’s call them devices as defined in ‘Device’ class. 12345678910interface IDevice &#123; void send(String message);&#125;class TcpDevice implements IDevice &#123; void send(String message) &#123;/*TCP impl.*/&#125;&#125;class MailDevice implements IDevice &#123; void send(String message) &#123;/*Mail Impl.*/&#125;&#125; We also have a messenger that uses a Device to send a message. Note that the derivations return the type of device they need for messaging. 123456789101112131415161718abstract class Messenger &#123; send(String message) &#123; IDevice Device = createDevice(); Device.send(message); &#125; abstract IDevice createDevice();&#125;class TcpMessenger extends Messenger &#123; IDevice createDevice() &#123; return new TcpDevice(); &#125;&#125;class MailMessenger extends Messenger &#123; IDevice createDevice() &#123; return new MailDevice(); &#125;&#125; Now, if the client needs to send a TCP message, it only needs to create a ‘TcpMessenger’ and the creation will be taken care of. 123456class Client &#123; Client() &#123; Messenger tcpMessenger = new TcpMessenger(); tcpMessenger.send(\"hello world!\"); &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Creational","slug":"Software-Architecture/Design-Patterns/Types/Creational","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Creational/"}]},{"title":"Observer Pattern","slug":"2010/observer","date":"2010-10-18T19:11:19.000Z","updated":"2016-09-18T14:19:06.000Z","comments":true,"path":"2010/observer/","link":"","permalink":"http://truelogician.com/2010/observer/","excerpt":"Design Patterns Overview DefinitionReceive topic updates from publisher by subscribing to them. Objects/subscribers are notified of an event when it happens or a topic when it’s published.","text":"Design Patterns Overview DefinitionReceive topic updates from publisher by subscribing to them. Objects/subscribers are notified of an event when it happens or a topic when it’s published. Recipe The topic (also called Context/Event/Observable) and its properties. 1interface ITopic &#123; /* properties */ &#125; The subscriber/observer interface and its concrete class. Notice how the topic/context is received. 12345678interface ISubscriber &#123; void onReceived(ITopic topic);&#125;class Subscriber implements ISubscriber &#123; void onReceived(ITopic topic) &#123; /* implementation */ &#125;&#125; The publisher interface and its concrete class that at least does the following 3 actions: subscribe: Adds the subscriber to the subscriber’s list. unsubscribe: Removes the subscriber from the subscriber’s list. publish: Notifies all subscribers in the list by invoking their onReceived(topic) method. 12345interface IPublisher &#123; void subscribe(ISubscriber subscriber); void unsubscribe(ISubscriber subscriber); void publish(ITopic topic);&#125; ServeThe snippet below demonstrate two subscribers that register themselves to receive topics/events from a publisher. At some point in time when the topic is ready (or the event is happened) the publisher notifies all subscribers about that. 1234567891011121314class Client &#123; Client() &#123; // create a publisher &amp; subscriber Publisher pub = new Publisher(); Subscriber sub1 = new Subscriber(); Subscriber sub2 = new Subscriber(); // subscribe to receive topics/events pub.subscribe(sub1); pub.subscribe(sub2); // now let's say some event happened and // we want to notify all subscribers pub.publish(new Topic()); &#125;&#125; Important BenefitsPublishers and subscribers are loosely coupled since publisher knows nothing about subscribers except that they implement the Subscriber’s interface by which they can be notified. ExampleImagine that an e-commerce system can receive a purchase order in the ‘OrderService’ class. As soon as the order is received, a confirmation mail shall be sent to user, the item shall be fetched from the inventory and finally the purchase amount shall be sent to accounting system. In this case, all these units should subscribe to the ‘OrderService’ class to be notified when an order is received. Let’s first define the topic which is an order in our case. 12345class Order implements ITopic &#123; String userEmail; String itemId; double price;&#125; Accordingly, the subscribers will look like this. 123456789class Inventory implements ISubscriber &#123; void onReceived(Order order) &#123;/* fetch item using order.itemId */&#125;&#125;class Confirmation implements ISubscriber &#123; void onReceived(Order order) &#123;/* send email using order.userMail */&#125;&#125;class Accounting implements ISubscriber &#123; void onReceived(Order order) &#123;/* proceed using order.price */&#125;&#125; Also, the OrderService will look like below 123456789101112class OrderService implements Publisher &#123; void subscribe(ISubscriber subscriber) &#123;/*implementation*/&#125; void unsubscribe(ISubscriber subscriber) &#123;/*implementation*/&#125; // Let's say we receive orders from clients here void onOrderReceived(Order order) &#123; publish(order); &#125; void publish(Order order) &#123; for (subscriber : subscribers) subscriber.onReceived(order) &#125;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Strategy Pattern","slug":"2010/strategy","date":"2010-09-07T20:14:58.000Z","updated":"2016-09-18T13:58:37.000Z","comments":true,"path":"2010/strategy/","link":"","permalink":"http://truelogician.com/2010/strategy/","excerpt":"Design Patterns Overview DefinitionAdding Behavior at Runtime. Strategy pattern encapsulates Interchangeable Behaviors and Uses Delegation to Decide Which One to Use.","text":"Design Patterns Overview DefinitionAdding Behavior at Runtime. Strategy pattern encapsulates Interchangeable Behaviors and Uses Delegation to Decide Which One to Use. Recipe The actual behavior (strategy) interface and concrete implementations. 123456789interface IBehavior &#123; void behave();&#125;class BehaviorA implements IBehavior &#123; void behave() &#123;/*implementation*/&#125;&#125;class BehaviorB implements IBehavior &#123; void behave() &#123;/*implementation*/&#125;&#125; The class that owns the behavior (called context) 123class Product &#123; IBehavior behavior;&#125; ServeIn the following snippet, the product is initiated with BehaviorA; however, at some point during runtime its behavior is changed to BehaviorB. 123456789class Client &#123; Client() &#123; Product p = new Product(); p.behavior = new BehaviorA(); // after a while if (/*shall change behavior?*/) p.behavior = new BehaviorB(); &#125;&#125; Important Benefits Composition over inheritance: The interchangeability of the behavior for the product class and its derivations. Causes the behavior independence from superclass or subclasses. Allows the behavior vary independently from the clients that use it. ExampleImagine there is a class called ‘Animal’. Also imaging that we want to provide the ‘Movement’ capability for it. Obviously this ability comes in different flavors for different animals. So, we know that we need an interface to define the generality of the behavior. 1interface IMovement &#123; void move(); &#125; In such case, the ‘Animal’ is called a “context class” and ‘Movability’ is called “behavior”.One way to do it, is to define an interface ‘IMovement’ and implement it within the ‘Animal’ class. 123class Animal implements IMovement &#123; void move() &#123;/*implementations*/&#125;&#125; Although this could also be one solution, due to reasons partly mentioned below, it’s better if we do NOT inherit the behavior but instead, own it: 123class Animal &#123; IMovement movement;&#125; Design Patterns Overview","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Types","slug":"Software-Architecture/Design-Patterns/Types","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/"},{"name":"Behavioral","slug":"Software-Architecture/Design-Patterns/Types/Behavioral","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Types/Behavioral/"}]},{"title":"Design Patterns Cookbook","slug":"2010/design-patterns","date":"2010-09-07T18:52:07.000Z","updated":"2016-09-18T15:27:51.000Z","comments":true,"path":"2010/design-patterns/","link":"","permalink":"http://truelogician.com/2010/design-patterns/","excerpt":"Even after reading the original GoF book and “Head First Design Patterns” (which is one of the best book in this field), as well as many articles, I still found it very daunting and hard to grasp the gist of each pattern and apply the most suitable one for a certain scenario. All the examples and UML diagrams do help understanding the pattern, but deep down, developers are far better at reading code; specially code snippets.","text":"Even after reading the original GoF book and “Head First Design Patterns” (which is one of the best book in this field), as well as many articles, I still found it very daunting and hard to grasp the gist of each pattern and apply the most suitable one for a certain scenario. All the examples and UML diagrams do help understanding the pattern, but deep down, developers are far better at reading code; specially code snippets. This became the very reason for me to start describing patterns in an easier manner and friendlier format. In a way that I was expected to be explained when I began. Each pattern are described in 5 sections: Definition: One or two sentence to describe the essence of the pattern. Recipe: Introducing the basic elements and the nuts and bolts of a pattern. Serve: Putting it all together to see how the pattern is served to the client code. Benefits: Mentioning some few important benefits of the pattern. Example: Giving a trivial concrete example to help reader remember the pattern. A section like ‘When to Use’ is intentionally ignored since I believe if developers understand the pattern thoroughly, then they will realize which one to use when they encounter a problem. What is a Design PatternI believe the Wikipedia‘s definition of design pattern is quite clear. It basically states that a design pattern is a general solution to problems that we developers usually encounter on daily basis while adding new features or refactoring code. They are not finished solution for specific problems nor they can be transformed directly into source code. Design Patterns ClassificationClassical Design Patterns are essentially divided in 3 categories. Each category addresses problems in a specific much wider area of software development. Behavioral PatternsBehavioral patterns are those that concern the different aspects of the behaviors that your entities might take on. These patterns help your design to be more resilient to change specifically when the change concerns the communication between objects. Strategy Change a Product’s Behavior at Runtime Observer Be Notified When Something Happens Command Create a Set of Reusable Commands For Various Products State Change the Behavior According to the State Template Method Create a Fixed Procedure and Vary Its Details in Subclasses Visitor Define an Operation, Move Various Implementations Elsewhere Interpreter Map, Translate or Interpret Data Into Different Formats Chain of Responsibility Pass a Product to a Chain of Processors Iterator Get the Iterator for Any Type of Collections in Subclasses Mediator Centralize Communications Among Related Objects Memento Create a Restore Point to Revert Object State Creational PatternsCreational patterns are ones that create objects for you, rather than having you instantiate objects directly. This gives your program more flexibility in deciding which objects need to be created for a given case (Wikipedia). Factory Method Create Objects Without Knowing Their Specific Type Abstract Factory Group Factories of Similar Products Singleton Making Only One Object of a Class to Be Available for All Prototype Create New Objects by Cloning Builder Simplify Creation of Objects With Many Properties Structural PatternsThese patterns concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality (Wikipedia) Adapter Create Adaptability Among Different Interfaces Decorator Provide New Abilities/Behaviors at Runtime Composite Add the Capability of Never Ending Grouping Bridge Decouple Products from Their Usage To Allow Independent Changes Facade Provide a Simplified Interface to a Set of Classes Flyweight Improve Performance by Sharing Objects Instead of Creating Them Proxy Limit Access to a Sensitive Properties and Behaviors of a Class","categories":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Overview","slug":"Software-Architecture/Design-Patterns/Overview","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Overview/"}],"tags":[{"name":"Design-Patterns","slug":"Design-Patterns","permalink":"http://truelogician.com/tags/Design-Patterns/"},{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"}],"keywords":[{"name":"Software Architecture","slug":"Software-Architecture","permalink":"http://truelogician.com/categories/Software-Architecture/"},{"name":"Design Patterns","slug":"Software-Architecture/Design-Patterns","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/"},{"name":"Overview","slug":"Software-Architecture/Design-Patterns/Overview","permalink":"http://truelogician.com/categories/Software-Architecture/Design-Patterns/Overview/"}]},{"title":"Better Naming Practices","slug":"2010/naming","date":"2010-07-03T14:47:19.000Z","updated":"2016-10-28T08:19:08.000Z","comments":true,"path":"2010/naming/","link":"","permalink":"http://truelogician.com/2010/naming/","excerpt":"Since code is read many times more than is written, then code readability becomes of extremely high importance among developers. Naming among other readability factors becomes the coder’s crucial task that needs more attention and scrutiny.","text":"Since code is read many times more than is written, then code readability becomes of extremely high importance among developers. Naming among other readability factors becomes the coder’s crucial task that needs more attention and scrutiny. The following is written from personal views and readings in form of tips and/or suggestions with hope of illuminating this topic from angles that you might have not been considered before. Tips / SuggestionsVariables are usually data containers. So, in case the contained data is quantifiable try to be clear about what is the content what is its unit of measurement. 1long intervalInMillis = 3500; A kind of poor variable names are those abbreviated Unix names since they are usually mis-informative. 123String cd;int sco;double ps; It would be much better not to use the postfix ‘List’ on variable names containing a group of objects unless they are actually based on list data-structure. 12Employee[] employeeList;HashTable&lt;String, Device&gt; deviceList; Using single letter names might be alright for short loops and small scopes but even in that case it can exponentially get harder to understand as it gets more complex; Moreover, they can also be severely hard to track throughout wider scopes. In the for-loop example below although the logic is cramped into one line, still variable names play a crucial role in crunching the knowledge there. 12345int l = 1, O = 0;for (int j=0; j&lt;34; j++) &#123; s += Math.pow(t[j/Math.round(x/5.5)]*35.7)/5;&#125; Additionally, although today’s IDEs are quite advanced to find all usages of a variable or method, yet choosing a very popular and common name could still prevent developers from rapidly tracing them. Imagine if all loops were about to use ‘i’ as the loop variable throughout a relatively large code base, then guess how many search hits we will get if we’re about to look for a specific one. 1for(int i = 0; i &lt; ...; i++) A rule of thumb is that shorter names are usually better than the longer ones; however long and similar names are always ambiguous and hard to distinguish and can become points of mistakes. 12Handler CustomerOrderHandlerForIncomingQueuedOrders;Handler CustomerOrderHandlerForIncomingStoredOrders; using prefixes such as ‘a’ or ‘the’ could be helpful if they convey the true nature of the variable. 12345Person thePerson;for (Person aPerson : personnel) &#123; if (person.id() != id) continue; thePerson = aPerson;&#125; Use names that are easily pronounced. They will ease communication about the code with other developers and they are easier to remember. 12Employee rchAndDevDepMngmt;Handler httpWsWsdlSoapMsgHndlr; Another bad naming habit is encoding variable types into their names. In a strongly typed language like Java, developers are inevitably presented with the variable type; as a result, adding type to variable names is both redundant and misleading after future refactoring. 123String ipAddressString;// what if IpAddress is later on moved into its own class as below?IpAddress ipAddressString; I guess this one is mostly a matter of developers taste but I’ve seen conventional prefixes/suffixes (such as Android ‘m’ prefix for member variables or ‘_‘ prefix in C# for the same reason) that never earned importance in code clarity in my personal view. Adding a couple of ‘this’ keywords might not affect coding time or the readability, but those prefixes/suffixes will gradually become clutter over time as they don’t play a crucial role in code clarity. 123456789101112public class Person &#123; private string _name; public string Name &#123; get &#123; return _name; &#125; set &#123; _name = value; &#125; &#125; public Person(string name) &#123; _name = name; &#125;&#125; However, I personally adapted some of them such as “adding ‘I’ prefix to indicate an interface” soon after learning and finding out their benefits. Well, The fact that interfaces in each namespace are grouped together and that a class can be distinguished from its interface by a quick glance to the IDE’s explorer view is very convincing for me. Additionally, this keeps the original name reserved for the probable abstract class which implements common functionalities for the family. But then again, some consider this prefixing redundant; as uncle bob states in his book ‘Clean Code’: Leave interfaces unadorned. If possible, do NOT use verbs for class names and as for method names, you may usually want to start them with a verb. Look how the following snippet easily conveys its intent. 12orderService.process(order);mailClient.sendConfirmation(message, recipient); While choosing method names, try to be meticulous about informing its true intent. An action that in the first glance seems like ‘add’, might indeed be an ‘append’, ‘insert’ or ‘concatenate’. Moreover, choose consistent words for same behaviors; meaning that, for a ‘get’ action, always use one of the phrases ‘get’, ‘fetch’, ‘receive’ or ‘retrieve’ all the time. In case of having overloaded constructors in your class, prefer the use of static factory methods that are named after received arguments and already hands more information. Accordingly, a class like this: 1234class Point &#123; Point(double x, double y) &#123;...&#125; Point(double radian, double distance) &#123;...&#125;&#125; might be more readable during instantiation with the following static factory methods. 123456789101112class Point &#123; private Point(double x, double y) &#123;...&#125; private Point(double radian, double distance) &#123;...&#125; public static inCartesian(double x, double y) &#123; return new Point(x, y); &#125; public static inPolar(double radian, double distance) &#123; return new Point(radian, distance); &#125;&#125; If at all possible, avoid mentioning customer/company names. 12class CompanyAbcSelector &#123;&#125;void companyXyzSort(Collection items) &#123;&#125; instead try to come up with design pattern names, known algorithms names or famous mathematical terms. 12class CellSelectionStrategy &#123;&#125;void quickSort(Collection items) &#123;&#125; ConclusionA quality code should be able to easily convey the flow of logic to the reader and shall not require any additional descriptions. Code is dynamic, changes and improves over time while comments are usually forgotten and rarely updated. Accordingly, use of proper descriptive naming greatly helps eliminating the need for comments and allows the code to narrate itself. Use names that reveal the true purpose behind what the logic is supposed to serve which in turn will result into more readable, understandable and more manageable code.","categories":[{"name":"Object-Oriented Design","slug":"Object-Oriented-Design","permalink":"http://truelogician.com/categories/Object-Oriented-Design/"},{"name":"Software Craftsmanship","slug":"Object-Oriented-Design/Software-Craftsmanship","permalink":"http://truelogician.com/categories/Object-Oriented-Design/Software-Craftsmanship/"}],"tags":[{"name":"Tutorials","slug":"Tutorials","permalink":"http://truelogician.com/tags/Tutorials/"},{"name":"Object-Oriented Design","slug":"Object-Oriented-Design","permalink":"http://truelogician.com/tags/Object-Oriented-Design/"},{"name":"Clean Code","slug":"Clean-Code","permalink":"http://truelogician.com/tags/Clean-Code/"},{"name":"Software Craftsmanship","slug":"Software-Craftsmanship","permalink":"http://truelogician.com/tags/Software-Craftsmanship/"},{"name":"Refactoring","slug":"Refactoring","permalink":"http://truelogician.com/tags/Refactoring/"},{"name":"Naming Practices","slug":"Naming-Practices","permalink":"http://truelogician.com/tags/Naming-Practices/"}],"keywords":[{"name":"Object-Oriented Design","slug":"Object-Oriented-Design","permalink":"http://truelogician.com/categories/Object-Oriented-Design/"},{"name":"Software Craftsmanship","slug":"Object-Oriented-Design/Software-Craftsmanship","permalink":"http://truelogician.com/categories/Object-Oriented-Design/Software-Craftsmanship/"}]}]}